<!-- Generated by SpecStory -->

<!-- cursor Session 8c5345e5-3639-48ad-ba57-38464f964d66 (2025-09-06 12:59Z) -->

# 重构视图功能以解决编译问题 (2025-09-06 12:59Z)

_**User (2025-09-06 08:18Z)**_

@BookListView.swift 编译卡住了，请重构下本视图功能

---

_**Assistant (gpt-5)**_



---

我先快速查看与该视图相关的数据访问与进度存储代码，定位可能导致编译/类型检查卡住的调用点，然后再重构为基于 ViewModel 的架构，将数据库查询移出视图构建阶段并做字符串预计算。随后我会直接提交对 `BookListView.swift` 的编辑。

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Data/Repositories.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Reading/ProgressStore.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Data/DatabaseManager.swift

---

<think><details><summary>Thought Process</summary>**Refactoring BookListView**

I need to refactor `BookListView.swift` to address compile freezes, potentially caused by nested closures and inline computed texts like `authorText` and `chapterText`. SwiftUI often struggles with large bodies or complex closures, leading to type-checking issues. I wonder if heavy generics are contributing to this hang. I think I could extract the row view into a separate `BookRowView` struct, which computes texts outside and simplifies the navigation logic. Alternatively, pushing some logic to a `BookListViewModel` might also help. I'll need to tread carefully, though, and not over-restructure.
**Improving BookListView Code**

I need to make code changes to `BookListView.swift` using code edit tools and avoiding dumping code. I’ll explore the current file to suggest changes. Notably, it utilizes `@EnvironmentObject` for `db`, `progressStore`, and `appAppearance`, which seems fine for search queries. However, the current approach calls `try? dbQueue.read` within the body to fetch each row's starting chapter, which could be costly. It might be better to compute `startChapterId` per book beforehand or modify `DatabaseManager.fetchBooks` to include this information directly.
**Modifying Navigation Logic**

I should avoid changing other files unnecessarily. Instead, I'll adjust to use `NavigationLink` with explicitly created destinations when tapped rather than during rendering. Since `NavigationLink` requires the destination type to conform to Hashable, and `Chapter` is already being used, I can modify the setup. Instead of computing the starting chapter during rendering, I could set up a `Button` to compute it on tap. We could also show the label row with a trailing chevron, compute the chapter at that moment, and navigate accordingly using `NavigationPath` or state.
**Refining Navigation with State**

I can add `@State private var selectedChapter: Chapter?` and use it with `.navigationDestination(for: Chapter.self)`. In the List row, I’ll wrap the row in a `Button` that fetches the chapter through the database on a background queue. Once that's set, I'll update the state on the main actor and navigate by using `NavigationLink(value: selectedChapter)`. Another option could be adding a hidden `NavigationLink` with selection binding. The iOS 17 updates allow for better versioning with `.navigationDestination(item:)`, but the existing code currently uses a value-based link setup. I might also consider using `NavigationPath` for navigation.
**Simplifying Navigation Logic**

I want to keep the `NavigationLink` but avoid querying the database to compute the starting chapter directly. Instead, I’ll compute the `Chapter` lazily using `Chapter(id: something)?`, though I might need the entire struct loaded since `Chapter` is likely a GRDB fetchable model. I could switch to using `NavigationLink(destination: ReaderView(chapter: ch))`, but I need the `ch` value first. Alternatively, I can use `NavigationLink(value: bookRow)` and set up `.navigationDestination(for: BookRow.self)`, which would move some logic outside the row. I have to ensure `BookRow` conforms to Hashable, so I’ll check the `Models.swift` file for that.</details></think>

---

我将并行打开与模型定义相关的文件以确认 `BookRow`、`Chapter` 等类型特性，并找出可能导致编译卡住的视图构建逻辑热点，然后进行针对性重构。

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Data/Models.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift

---

<think><details><summary>Thought Process</summary>**Considering code refactoring**

I'm thinking about restructuring the code to use smaller subviews and a ViewModel. I want to move heavy logic out and simplify things with smaller builder functions. Precomputing the startChapter for each BookRow at loadBooks time seems like a good idea. I also noticed that progressText uses db.unreadChapterCount, which causes repeated DB calls. It could be better if we fetch books and precompute fields first, or calculate in the background. I plan to implement these changes using the code edit tool and create todos for this multi-step refactor.
**Planning ViewModel integration**

I think a better approach would be to introduce `BookListViewModel: ObservableObject` in the `BookListView.swift` file or possibly create a new file for it. However, the instruction prefers using the code edit tool and avoids showing the code directly. Keeping everything in the same file would minimize changes, so I can include a `BookRowItem` struct with precomputed fields. My plan is to set up `@StateObject private var vm` in `BookListView` and implement the method to load books. I might also need to figure out how to pass parameters to the StateObject.
**Refining ViewModel and logic**

I'm considering defining parameterless references and setting up via the load function. The view body can use `List(viewModel.items)` to avoid complex duplication, which is a relief! I plan to move `TextFieldDialog` overlay to still utilize DB calls for renaming and deleting, and I might need to call `viewModel.refresh` afterwards.

I'll simplify things by removing unnecessary functions like startingChapter and relying on precomputed strings instead. In the ViewModel, I'll implement `@MainActor ObservableObject` with `@Published var items: [Item] = []`, and the `load(search:)` method will fetch books. I'll compute the start chapter in the background but ensure it doesn't block the main thread.
**Implementing thread safety and loading**

I'm thinking about implementing loading in a way that ensures thread safety in SwiftUI. My plan is to use `DispatchQueue.global(qos: .userInitiated).async` to perform the loading in the background and then publish results to the main thread.

The `load` function will fetch books from the database and create `items` by mapping over the raw results. I'll need to compute the startChapter and other texts. I'm also figuring out how to use `db.unreadChapterCount` for progress text calculations while making sure everything's on a background thread. One issue I noticed is that `NavigationLink(value:)` can't take optional values since it requires a type conforming to Hashable. That makes me pause a bit!
**Refactoring view and NavigationLink**

I've realized that in SwiftUI, `NavigationLink(value: ...)` can't take optional values. I'll implement a way to show the `NavigationLink` only if `startChapter` is non-optional by using an `if let` pattern.

I'll create a `BookRowView` subview to minimize repeated code and manage swipe actions for renaming and deleting. I'm inclined to keep the debounce for search at the view level and remove the local books state while retaining references for renaming and deleting.

Now, the plan is to modify the `BookListView.swift` file and consider the `apply_patch` method for changes, but I might need to confirm reading the file again first to ensure I'm working with the latest context. 

This patch will make several updates, maintaining existing structures while introducing new elements to improve readability and performance!
**Creating a todo list for refactoring**

I'm thinking about creating a todo list to guide my refactoring process. First, I need to establish the `BookListViewModel` and `Item` model, which are currently in progress. Then, I’ll refactor `BookListView` so it can use `viewModel.items` and simplify or remove heavy inline functions. 

I’ll ensure that delete and rename actions trigger a reload and clear the `progressStore`. Adding debounce is also on the agenda. Once I’ve made these code changes using `apply_patch`, I’ll run lints to check for any issues. Let's get started!</details></think>

---

我将创建一个视图模型以卸载数据库查询和字符串拼接逻辑，并重构 `BookListView` 使用该视图模型的数据源，从而减轻 SwiftUI 视图构建的编译负担。接下来我会直接修改 `BookListView.swift`。

---

Tool use: **todo_write**

## Todo List

- [-] 创建 BookListViewModel 以批量加载书籍、起始章节和展示文案
- [ ] 重构 BookListView 使用 viewModel.items 渲染行与导航
- [ ] 保留重命名/删除功能并在操作后刷新列表与进度清理

---

<think><details><summary>Thought Process</summary>**Refactoring BookListView**

I need to refactor BookListView.swift to prevent compilation hangs. The plan is to use a ViewModel, precompute strings, and move database queries out of the body. I’ll ensure it remains compatible with existing functions and environment objects. The current setup touches the dbQueue while rendering list rows, which could be heavy. So, I'll compute the startingChapter and text strings in a ViewModel, potentially in the background, and then publish those updates. I’ll either edit the file directly or create a new one for the ViewModel.
**Refactoring BookListView.swift**

The user asked for a refactor of BookListView.swift to fix compilation hangs. To keep changes minimal, I’ll implement an internal ViewModel in the same file, maintaining consistent indentation with 4 spaces. I won't output code in chat; instead, I'll use the apply_patch tool. I’ve read the file, so here's the plan: 

I’ll define a class called BookListViewModel that conforms to ObservableObject and includes @Published items. It will also require DatabaseManager and ProgressStore to load books. Functions will include loading searches, renaming books, and deleting them.
**Setting up BookListViewModel**

I’m thinking about the functions for renaming and deleting books, which will involve DatabaseManager and clearing progressStore. In the View struct, I can use @StateObject to hold the BookListViewModel. However, I need to pass in environment objects during initialization, and SwiftUI restricts that. To work around this, I can use .onAppear to call viewModel.configure(db, progressStore) once.

I also need to ensure thread safety while computing precomputations in the background. I’ll define the class with a method to handle configuration and data loading efficiently.
**Implementing BookListItem and Load Function**

For the implementation details, the BookListItem will include fields like id, bookRow, and optional startingChapter, along with authorText and chapterText, where I can store computed strings.

When loading books with `load(search:)`, I’ll use `db.fetchBooks(search:, progressStore:)` for synchronous DB reads. It might be quick, but could get heavy if called per keystroke, which I’m aware of since we already have a debounce in place.

After getting the bookRows, I’ll compute the startingChapter efficiently by checking for existing chapters by id, leveraging bulk queries to avoid unnecessary DB reads to optimize performance and manage potential compile-time complexity.
**Implementing Background Reading and Updates**

I’m considering moving database reading for chapters into the background to make it more efficient. I’ll create a method called `computeStartingChapters(for bookRows)` that leverages GRDB’s DatabaseQueue to handle multiple queries. The results will be stored in a local dictionary to keep it efficient.

Inside `buildItems(search:)`, I’ll process chapter fetching in an async manner. I’ll replace the current `books` state with a `@StateObject` for the view model and manage search changes with it. Actions for renaming and deleting books will also update the environment. I’ll ensure everything compiles correctly and integrate with existing components. Finally, I’ll implement these code changes using apply_patch in `BookListView.swift`.</details></think>

---

我将创建视图模型并重构 `BookListView.swift` 使用它来加载与渲染，缓解编译与构建压力。接下来进行代码编辑。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/book/BookReader/BookReader/Views/BookListView.swift</summary>
      

```diff
<<'PATCH'
*** Begin Patch
*** Update File: BookReader/Views/BookListView.swift
@@
-import GRDB
-import SwiftUI
-
-struct BookListView: View {
-    @EnvironmentObject private var db: DatabaseManager
-    @EnvironmentObject var progressStore: ProgressStore
-    @EnvironmentObject private var appAppearance: AppAppearanceSettings
-    @State private var books: [BookRow] = []
-    @State private var searchText = ""
-    @State private var searchDebounceTask: Task<Void, Never>? = nil
-    @State private var renamingBook: BookRow? = nil
-    @State private var newTitleText: String = ""
-    @State private var deletingBook: BookRow? = nil
-    @State private var showDeleteConfirm: Bool = false
-
-    var body: some View {
-        Group {
-            if db.dbQueue == nil {
-                // 数据库不存在时的提示
-                Text("请连接手机到电脑，在 文件 → BookReader 文件夹 内放入 novel.sqlite")
-                    .padding()
-                    .multilineTextAlignment(.center)
-            } else {
-                NavigationStack {
-                    List(books) { bookRow in
-                        if let startChapter = startingChapter(for: bookRow) {
-                            NavigationLink(value: startChapter) {
-                                VStack(alignment: .leading) {
-                                    Text(bookRow.book.title).font(.headline)
-                                    let authorText = makeAuthorText(
-                                        bookRow: bookRow
-                                    )
-                                    if !authorText.isEmpty {
-                                        Text(authorText)
-                                            .font(.caption)
-                                            .foregroundColor(.secondary)
-                                    }
-
-                                    // 书籍额外信息：最新章节、总字数、完本状态
-                                    HStack(spacing: 8) {
-                                        let chapterText = makeChapterText(
-                                            bookRow: bookRow
-                                        )
-                                        if !chapterText.isEmpty {
-                                            Text(chapterText)
-                                        }
-                                    }
-                                    .font(.caption)
-                                    .foregroundColor(.secondary)
-                                }
-                            }
-                            .swipeActions(
-                                edge: .trailing,
-                                allowsFullSwipe: false
-                            ) {
-                                Button("重命名") {
-                                    renamingBook = bookRow
-                                    newTitleText = bookRow.book.title
-                                }
-                                .tint(.blue)
-                                Button(role: .destructive) {
-                                    deletingBook = bookRow
-                                    showDeleteConfirm = true
-                                } label: {
-                                    Text("删除")
-                                }
-                            }
-                        } else {
-                            // 若没有可用章节，禁用跳转但仍显示条目
-                            VStack(alignment: .leading) {
-                                Text(bookRow.book.title).font(.headline)
-                                let authorText = makeAuthorText(
-                                    bookRow: bookRow
-                                )
-                                if !authorText.isEmpty {
-                                    Text(authorText)
-                                        .font(.caption)
-                                        .foregroundColor(.secondary)
-                                }
-                                Text("无可阅读章节").font(.caption).foregroundColor(
-                                    .secondary
-                                )
-                            }
-                            .swipeActions(
-                                edge: .trailing,
-                                allowsFullSwipe: false
-                            ) {
-                                Button("重命名") {
-                                    renamingBook = bookRow
-                                    newTitleText = bookRow.book.title
-                                }
-                                .tint(.blue)
-                                Button(role: .destructive) {
-                                    deletingBook = bookRow
-                                    showDeleteConfirm = true
-                                } label: {
-                                    Text("删除")
-                                }
-                            }
-                        }
-                    }
-                    .searchable(text: $searchText)
-                    .onChange(of: searchText) { oldValue, newValue in
-                        // 防抖：避免输入法组合期间频繁刷新
-                        searchDebounceTask?.cancel()
-                        searchDebounceTask = Task { @MainActor in
-                            try? await Task.sleep(nanoseconds: 300_000_000)  // 0.3s
-                            loadBooks(search: newValue)
-                        }
-                    }
-                    .navigationTitle("书籍")
-                    .toolbar {
-                        ToolbarItem(placement: .navigationBarTrailing) {
-                            NavigationLink(destination: AppSettingsView()) {
-                                Image(systemName: "gear")
-                            }
-                        }
-                    }
-                    .onAppear { loadBooks(search: searchText) }
-                    .navigationDestination(for: Chapter.self) { ch in
-                        ReaderView(chapter: ch)
-                    }
-                    .overlay {
-                        if let renaming = renamingBook {
-                            TextFieldDialog(
-                                title: "重命名",
-                                placeholder: "请输入新的书名",
-                                text: $newTitleText,
-                                onCancel: { renamingBook = nil },
-                                onSave: {
-                                    let trimmed =
-                                        newTitleText.trimmingCharacters(
-                                            in: .whitespacesAndNewlines
-                                        )
-                                    guard !trimmed.isEmpty else {
-                                        renamingBook = nil
-                                        return
-                                    }
-                                    db.updateBookTitle(
-                                        bookId: renaming.book.id,
-                                        title: trimmed
-                                    )
-                                    loadBooks(search: searchText)
-                                    renamingBook = nil
-                                }
-                            )
-                            .transition(.opacity)
-                            .zIndex(1)
-                        }
-                        if showDeleteConfirm, let target = deletingBook {
-                            ConfirmDialog(
-                                title: "删除确认",
-                                message: "此操作将删除该书的所有内容与阅读进度，且不可恢复。是否继续？",
-                                confirmTitle: "删除",
-                                cancelTitle: "取消",
-                                onCancel: {
-                                    showDeleteConfirm = false
-                                    deletingBook = nil
-                                },
-                                onConfirm: {
-                                    db.deleteBook(bookId: target.book.id)
-                                    progressStore.clear(forBook: target.book.id)
-                                    loadBooks(search: searchText)
-                                    showDeleteConfirm = false
-                                    deletingBook = nil
-                                }
-                            )
-                            .transition(.opacity)
-                            .zIndex(2)
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private func loadBooks(search: String? = nil) {
-        books = db.fetchBooks(
-            search: search?.isEmpty == true ? nil : search,
-            progressStore: progressStore
-        )
-    }
-
-    // 计算进入阅读时的起始章节：优先使用上次进度，否则为第一章
-    private func startingChapter(for bookRow: BookRow) -> Chapter? {
-        guard let dbQueue = db.dbQueue else { return nil }
-        if let last = bookRow.lastProgress {
-            if let chapter = try? dbQueue.read({ db in
-                try Chapter.filter(Column("id") == last.chapterId).fetchOne(db)
-            }) {
-                // 防御：仅当进度章节属于当前书时才采用
-                if chapter.bookid == bookRow.book.id {
-                    return chapter
-                }
-            }
-        }
-        // 无进度或进度章节不匹配/不存在时，取第一章
-        return try? dbQueue.read { db in
-            try Chapter.filter(Column("bookid") == bookRow.book.id)
-                .order(Column("id"))
-                .fetchOne(db)
-        }
-    }
-
-    // 列表展示的阅读进度文案
-    private func progressText(for book: Book) -> String {
-        if let last = progressStore.lastProgress(forBook: book.id) {
-            let unread = db.unreadChapterCount(
-                bookId: book.id,
-                afterChapterId: last.chapterId
-            )
-            return unread == 0 ? "读完" : "\(unread)章未读"
-        } else {
-            return "未读"
-        }
-    }
-
-    // 组合分类与进度为单行文案
-    private func makeAuthorText(bookRow: BookRow) -> String {
-        let progress = progressText(for: bookRow.book)
-
-        var parts: [String] = []
-        // if !bookRow.categoryTitle.isEmpty { parts.append(bookRow.categoryTitle) }
-        if !bookRow.book.author.isEmpty { parts.append(bookRow.book.author) }
-        if !progress.isEmpty { parts.append(progress) }
-
-        return parts.joined(separator: "・")
-    }
-
-    // 组合最新章节和完本信息为单行文案
-    private func makeChapterText(bookRow: BookRow) -> String {
-
-        var parts: [String] = []
-
-        // if !bookRow.book.wordcount.isEmpty { parts.append(bookRow.book.wordcount) }
-        if bookRow.book.isfinished == 1 { parts.append("完本") }
-        if !bookRow.book.latest.isEmpty { parts.append(bookRow.book.latest) }
-
-        return parts.joined(separator: "・")
-    }
-}
+import GRDB
+import SwiftUI
+
+// MARK: - ViewModel
+final class BookListViewModel: ObservableObject {
+    struct Item: Identifiable, Equatable {
+        var id: Int { bookRow.book.id }
+        let bookRow: BookRow
+        let startChapter: Chapter?
+        let authorText: String
+        let chapterText: String
+    }
+
+    @Published private(set) var items: [Item] = []
+    private weak var db: DatabaseManager?
+    private weak var progressStore: ProgressStore?
+
+    @MainActor
+    func configure(db: DatabaseManager, progressStore: ProgressStore) {
+        if self.db == nil { self.db = db }
+        if self.progressStore == nil { self.progressStore = progressStore }
+    }
+
+    @MainActor
+    func load(search: String?) {
+        guard let db = db, let progressStore = progressStore else { return }
+        let query = (search?.isEmpty == true) ? nil : search
+        // 先同步取基本行（内部已批量拉取进度）
+        let rows = db.fetchBooks(search: query, progressStore: progressStore)
+        // 再后台计算起始章节与展示文案
+        Task.detached(priority: .userInitiated) { [weak self] in
+            guard let self = self else { return }
+            let computed = self.buildItems(rows: rows, db: db)
+            await MainActor.run { self.items = computed }
+        }
+    }
+
+    @MainActor
+    func refreshKeepingSearch(_ search: String?) { load(search: search) }
+
+    // MARK: - Private
+    private func buildItems(rows: [BookRow], db: DatabaseManager) -> [Item] {
+        guard let dbQueue = db.dbQueue else { return [] }
+
+        // 批量在一次 read 事务里求起始章节，避免在 List 中逐行触发 IO
+        let startMap: [Int: Chapter?] = (try? dbQueue.read { db in
+            var result: [Int: Chapter?] = [:]
+            for r in rows {
+                var start: Chapter?
+                if let last = r.lastProgress {
+                    if let ch = try Chapter
+                        .filter(Column("id") == last.chapterId)
+                        .fetchOne(db), ch.bookid == r.book.id
+                    {
+                        start = ch
+                    }
+                }
+                if start == nil {
+                    start = try Chapter
+                        .filter(Column("bookid") == r.book.id)
+                        .order(Column("id"))
+                        .fetchOne(db)
+                }
+                result[r.book.id] = start
+            }
+            return result
+        }) ?? [:]
+
+        // 计算展示文案（纯字符串拼接）
+        func progressText(for book: Book) -> String {
+            if let last = progressStore?.lastProgress(forBook: book.id) {
+                let unread = db.unreadChapterCount(
+                    bookId: book.id,
+                    afterChapterId: last.chapterId
+                )
+                return unread == 0 ? "读完" : "\(unread)章未读"
+            } else {
+                return "未读"
+            }
+        }
+
+        func authorText(for row: BookRow) -> String {
+            let progress = progressText(for: row.book)
+            var parts: [String] = []
+            if !row.book.author.isEmpty { parts.append(row.book.author) }
+            if !progress.isEmpty { parts.append(progress) }
+            return parts.joined(separator: "・")
+        }
+
+        func chapterText(for row: BookRow) -> String {
+            var parts: [String] = []
+            if row.book.isfinished == 1 { parts.append("完本") }
+            if !row.book.latest.isEmpty { parts.append(row.book.latest) }
+            return parts.joined(separator: "・")
+        }
+
+        return rows.map { row in
+            Item(
+                bookRow: row,
+                startChapter: startMap[row.book.id] ?? nil,
+                authorText: authorText(for: row),
+                chapterText: chapterText(for: row)
+            )
+        }
+    }
+}
+
+// MARK: - View
+struct BookListView: View {
+    @EnvironmentObject private var db: DatabaseManager
+    @EnvironmentObject var progressStore: ProgressStore
+    @EnvironmentObject private var appAppearance: AppAppearanceSettings
+
+    @StateObject private var viewModel = BookListViewModel()
+    @State private var searchText = ""
+    @State private var searchDebounceTask: Task<Void, Never>? = nil
+    @State private var renamingBook: BookRow? = nil
+    @State private var newTitleText: String = ""
+    @State private var deletingBook: BookRow? = nil
+    @State private var showDeleteConfirm: Bool = false
+
+    var body: some View {
+        Group {
+            if db.dbQueue == nil {
+                Text("请连接手机到电脑，在 文件 → BookReader 文件夹 内放入 novel.sqlite")
+                    .padding()
+                    .multilineTextAlignment(.center)
+            } else {
+                NavigationStack {
+                    List(viewModel.items) { item in
+                        if let startChapter = item.startChapter {
+                            NavigationLink(value: startChapter) {
+                                VStack(alignment: .leading) {
+                                    Text(item.bookRow.book.title).font(.headline)
+                                    if !item.authorText.isEmpty {
+                                        Text(item.authorText)
+                                            .font(.caption)
+                                            .foregroundColor(.secondary)
+                                    }
+                                    HStack(spacing: 8) {
+                                        if !item.chapterText.isEmpty {
+                                            Text(item.chapterText)
+                                        }
+                                    }
+                                    .font(.caption)
+                                    .foregroundColor(.secondary)
+                                }
+                            }
+                            .swipeActions(edge: .trailing, allowsFullSwipe: false) {
+                                Button("重命名") {
+                                    renamingBook = item.bookRow
+                                    newTitleText = item.bookRow.book.title
+                                }
+                                .tint(.blue)
+                                Button(role: .destructive) {
+                                    deletingBook = item.bookRow
+                                    showDeleteConfirm = true
+                                } label: {
+                                    Text("删除")
+                                }
+                            }
+                        } else {
+                            VStack(alignment: .leading) {
+                                Text(item.bookRow.book.title).font(.headline)
+                                if !item.authorText.isEmpty {
+                                    Text(item.authorText)
+                                        .font(.caption)
+                                        .foregroundColor(.secondary)
+                                }
+                                Text("无可阅读章节")
+                                    .font(.caption)
+                                    .foregroundColor(.secondary)
+                            }
+                            .swipeActions(edge: .trailing, allowsFullSwipe: false) {
+                                Button("重命名") {
+                                    renamingBook = item.bookRow
+                                    newTitleText = item.bookRow.book.title
+                                }
+                                .tint(.blue)
+                                Button(role: .destructive) {
+                                    deletingBook = item.bookRow
+                                    showDeleteConfirm = true
+                                } label: {
+                                    Text("删除")
+                                }
+                            }
+                        }
+                    }
+                    .searchable(text: $searchText)
+                    .onChange(of: searchText) { oldValue, newValue in
+                        searchDebounceTask?.cancel()
+                        searchDebounceTask = Task { @MainActor in
+                            try? await Task.sleep(nanoseconds: 300_000_000)
+                            viewModel.load(search: newValue)
+                        }
+                    }
+                    .navigationTitle("书籍")
+                    .toolbar {
+                        ToolbarItem(placement: .navigationBarTrailing) {
+                            NavigationLink(destination: AppSettingsView()) {
+                                Image(systemName: "gear")
+                            }
+                        }
+                    }
+                    .onAppear {
+                        viewModel.configure(db: db, progressStore: progressStore)
+                        viewModel.load(search: searchText)
+                    }
+                    .navigationDestination(for: Chapter.self) { ch in
+                        ReaderView(chapter: ch)
+                    }
+                    .overlay {
+                        if let renaming = renamingBook {
+                            TextFieldDialog(
+                                title: "重命名",
+                                placeholder: "请输入新的书名",
+                                text: $newTitleText,
+                                onCancel: { renamingBook = nil },
+                                onSave: {
+                                    let trimmed = newTitleText.trimmingCharacters(
+                                        in: .whitespacesAndNewlines
+                                    )
+                                    guard !trimmed.isEmpty else {
+                                        renamingBook = nil
+                                        return
+                                    }
+                                    db.updateBookTitle(
+                                        bookId: renaming.book.id,
+                                        title: trimmed
+                                    )
+                                    viewModel.refreshKeepingSearch(searchText)
+                                    renamingBook = nil
+                                }
+                            )
+                            .transition(.opacity)
+                            .zIndex(1)
+                        }
+                        if showDeleteConfirm, let target = deletingBook {
+                            ConfirmDialog(
+                                title: "删除确认",
+                                message: "此操作将删除该书的所有内容与阅读进度，且不可恢复。是否继续？",
+                                confirmTitle: "删除",
+                                cancelTitle: "取消",
+                                onCancel: {
+                                    showDeleteConfirm = false
+                                    deletingBook = nil
+                                },
+                                onConfirm: {
+                                    db.deleteBook(bookId: target.book.id)
+                                    progressStore.clear(forBook: target.book.id)
+                                    viewModel.refreshKeepingSearch(searchText)
+                                    showDeleteConfirm = false
+                                    deletingBook = nil
+                                }
+                            )
+                            .transition(.opacity)
+                            .zIndex(2)
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
@@
 #Preview {
     BookListView()
         .environmentObject(DatabaseManager.shared)
         .environmentObject(ProgressStore())
 }
*** End Patch
PATCH
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 1 file</summary>
      
Lint paths:

- `/Users/zgia/program/book/BookReader/BookReader/Views/BookListView.swift`

Lint results


**No lint errors found**
</details>

---

Tool use: **todo_write**

## Todo List

- [x] 创建 BookListViewModel 以批量加载书籍、起始章节和展示文案
- [x] 重构 BookListView 使用 viewModel.items 渲染行与导航
- [x] 保留重命名/删除功能并在操作后刷新列表与进度清理

---

我已把数据加载与起始章节/文案计算移入 `BookListViewModel`，`BookListView` 仅渲染 `viewModel.items` 并处理操作，避免在 View 构建时触发数据库访问导致编译卡住。

- 关键改动
  - 新增 `BookListViewModel`，统一加载 `BookRow`、批量计算起始章节与展示文案，并在后台线程处理重活。
  - `BookListView` 使用 `@StateObject viewModel`，`search` 防抖后调用 `viewModel.load`。
  - 保留“重命名/删除”逻辑，操作后调用 `viewModel.refreshKeepingSearch` 刷新；删除时依旧清理 `ProgressStore`。
  - `NavigationLink` 的 `value` 使用预计算的 `startChapter`，无可读章节时降级为静态行。

- 编译/风格
  - 通过本地静态检查，无新增 linter 报错。
  - 保持原有 UI 行为与字符串文案。

如需把“读完/未读/未读数量”的计算也完全异步化或加入缓存，我可以继续优化。

---

