<!-- Generated by SpecStory -->

<!-- cursor Session 1d21b13c-f9ab-4e7a-836d-b78409906b0f (2025-08-30 15:24Z) -->

# TopControlsView 显示问题分析 (2025-08-30 15:24Z)

_**User (2025-08-30 15:11Z)**_

期间优化了一次代码，把topControlsView等独立出来了，@ReaderView.swift 现在topControlsView不显示图书名称，加载目录也失败了，请问是什么原因呢？

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Investigating SQL error possibilities**

I'm thinking that there's a chance a SQL error could occur, or perhaps no rows are returned. In that case, GRDB might give a nil row, leading to a constructed Book with an empty title. If the title is empty, it wouldn't show up. "加载目录失败" could relate to ChapterListView expecting a valid book ID. It seems like ChapterListView needs a non-nil book variable, which complicates loading the catalog if currentBook isn't set correctly. There might be an issue with the SQL query, possibly a wrong WHERE alias.
**Analyzing Book fetching logic**

I'm examining the SQL query where `book.id = ?`. It seems that if there's no row found, a Book is still returned with an empty title. This means that while currentBook isn't nil, its title is empty. The topControlsView uses `!title.isEmpty`, which prevents it from rendering. ChapterListView gets a Book with empty fields, but it likely uses `book.id` to fetch chapters. If the currentChapter.bookid is set, it should fetch correctly. So why is "加载目录失败" still appearing? The else branch shows "正在加载目录..." only if currentBook is nil, which shouldn’t be the case.
**Examining currentBook loading issues**

I'm realizing that loadCurrentBook is called after loading content, but showCatalog might be toggled before currentBook completely populates. The user can toggle showCatalog via a button, and currentBook is set during the loadCurrentBook function, which runs when ReaderView appears. The default fallback gives a Book with an empty title but a valid ID, so ChapterListView should display. However, if currentBook is actually nil at runtime, that would cause the loading issue. Since currentBook is optional and not initialized initially, it could stay nil if dbQueue is not ready, which seems unlikely since it's used elsewhere.
**Exploring potential bugs in code**

I'm considering that the change to extract topControlsView into a separate function could lead to issues if state is captured incorrectly in SwiftUI. Their function `topControlsView(title: String) -> some View` seems fine and isn't causing logic bugs. I should check ReaderView's initialization, which uses the correct State. In onAppear, they call updateAdjacentRefs(), but top overlay passes `currentBook?.title ?? ""`. Even if the title is available, showControls must be toggled true to display it, and if the title is empty due to an SQL alias bug, it won't show. The "加载目录失败" issue might be related to how currentChapter is set in ChapterListView.
**Examining currentBook initialization issues**

I'm recognizing that if currentBook is nil, the code will show the else branch, which displays "正在加载目录..." This happens if loadCurrentBook isn't executed or if it doesn't set currentBook. Previously, I thought it would still be set due to the default fallback unless `dbQueue` is nil, which would skip the assignment. The guard statement indicates that if currentBook isn't nil, execution returns early. However, if dbQueue is nil, currentBook remains nil. I need to check DatabaseManager.swift to see if dbQueue is initialized early in the app, as instructed. I'll read through relevant files in parallel to debug effectively.</details></think>

---

让我先查阅相关实现，看看为什么书名不显示以及目录弹窗未能加载。我会同时打开数据库管理、模型定义和目录视图的实现以定位问题。

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Data/DatabaseManager.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Data/Models.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Views/ChapterListView.swift

---

<think><details><summary>Thought Process</summary>**Examining SQL aliases**

I'm considering how SQL aliases work, specifically when using "book.id" with an alias like "b." It seems referencing "book.id" might still be valid since there's a 'book' table name. However, I remember that when you alias a table, you usually need to use the alias for all columns. In many RDBMS, referencing the original name might lead to errors like "no such column." I'm not completely sure if this applies to SQLite, though; maybe it still allows referencing the original name.
**Analyzing SQL query issues**

I'm looking at the function `loadCurrentBook`, which uses a `LEFT JOIN` to connect categories and authors. The selection of columns seems fine, but then the else branch returns a Book with an empty title, leading to `topControlsView` not displaying anything. I suspect the query might not return a row because the `WHERE` clause incorrectly references "book.id." It should use "b.id." If no row is found, then setting the Book with an empty title would explain the absence of titles and issues in the chapter list.
**Exploring ChapterListView issues**

It looks like `showCatalog` should display `ChapterListView` with the book, since currentBook is non-nil. However, currentBook is only set in `loadCurrentBook` after `onAppear`, yet it's still set even if not found. The failure to load might be due to `DatabaseManager.dbQueue` being nil, but it seems the app can read content from the DB successfully. Since `ChapterListView` uses `book.id` to load volumes and chapters, it should work regardless of an empty title. The "目录加载失败" message could indicate that the sheet isn’t displaying the chapter list correctly.
**Investigating potential issues**

I’m considering whether the sheet needs a `NavigationStack` in iOS 17, although it worked previously. Alternatively, there might be an issue with the top overlay using `.overlay(alignment: .top)`, but this looks fine within a `ZStack`. The real concern seems to stem from an SQL query using `WHERE book.id = ?`, where it references 'book' instead of the alias 'b.' In SQLite, using an original table name after aliasing leads to errors. It looks like they’re using `try Row.fetchOne`, but they might not be catching potential errors effectively. This could lead to a failure in setting `currentBook`.
**Identifying and fixing issues**

I see that if an error occurs, `try?` will lead to `currentBook` being set to nil, which is a problem. This means the `showCatalog` function fails, resulting in "正在加载目录..." being displayed. The root cause appears to be an SQL error with an alias mismatch, specifically "WHERE book.id = ?" instead of "WHERE b.id = ?." 

I need to update the `loadCurrentBook` function to extract both the author and category properly, using `let author: String = (row["author"] as String?) ?? ""` and `let category: String = (row["category"] as String?) ?? ""`. Then it's essential to apply these changes with the `apply_patch` tool and also include a status update before doing so, stating "我找到了 SQL 别名错误, 现在修复."</details></think>

---

我发现 `loadCurrentBook()` 的 SQL 用了表别名 `b` 却在 WHERE 子句里写了 `book.id`，这会导致查询报错，从而 `currentBook` 保持为 nil，进而书名不显示、目录也加载失败。我现在修改为 `b.id = ?`，并且把查询出来的 `author` 和 `category` 正确赋值给 `Book`。接着我会应用这个编辑。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift
@@
     private func loadCurrentBook() {
         guard currentBook == nil else { return }
         guard let dbQueue = DatabaseManager.shared.dbQueue else { return }
         currentBook = try? dbQueue.read { db in
             let sql = """
                     SELECT b.id, b.title, a.name AS author, c.title AS category,
                            b.latest AS latest, b.wordcount AS wordcount, b.isfinished AS isfinished
                     FROM book b
                     LEFT JOIN category c ON c.id = b.categoryid
                     LEFT JOIN book_author a ON a.id = b.authorid
-                    WHERE book.id = ?
+                    WHERE b.id = ?
                 """
             if let row = try Row.fetchOne(
                 db,
                 sql: sql,
                 arguments: [currentChapter.bookid]
             ) {
                 let id: Int = row["id"]
                 let title: String = (row["title"] as String?) ?? ""
+                let author: String = (row["author"] as String?) ?? ""
+                let category: String = (row["category"] as String?) ?? ""
                 let latest: String = (row["latest"] as String?) ?? ""
                 let wordcount: Int = (row["wordcount"] as Int?) ?? 0
                 let isfinished: Int = (row["isfinished"] as Int?) ?? 0
 
                 return Book(
                     id: id,
-                    category: "",
+                    category: category,
                     title: title,
-                    author: "",
+                    author: author,
                     latest: latest,
                     wordcount: wordcount,
                     isfinished: isfinished
                 )
             } else {
*** End Patch
```

---

<think><details><summary>Thought Process</summary>**Fixing SQL issues**

I realized that in `ReaderView`, if `currentBook` is nil due to an SQL error, the sheet content won't load, which leads to the “正在加载目录...” message showing instead. I fixed that by making sure we provide author and category values, not empty strings. We should also check for any other instances of `book.id` and updated the SQL query accordingly. Next, I’ll plan to send a status update and propose running the app after building it, although I'll be cautious about dependencies.
**Addressing developer concerns**

The developer wants us to address the issue thoroughly. The fix is relatively simple, and we can run `read_lints` without building. I also need to clarify that `topControlsView` doesn’t show if `title` is empty, which ties to the symptom "不显示图书名称." If the title is missing, nothing appears. It's crucial to point that out and advise users to toggle `showControls` and ensure `currentBook` loads properly. The root issue is an SQL alias bug, and after fixing it, everything should display correctly. I'll supply concise instructions for testing as well.
**Clarifying citation requirements**

I've got instructions about citing code snippets properly. When referencing code in the codebase, we should use a special code block format: "startLine:endLine:filepath." However, we don't strictly need to display the actual code; just an explanation will do. Including a summary with bullet points at the end is essential, and I want to provide a status update at the beginning since I’ll be calling `read_lints`. Let’s move forward with that plan!</details></think>

---

我先快速验证刚才的编辑没有引入新的语法/格式问题，然后再回来给你结论。

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 1 file</summary>
      
Lint paths:

- `/Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift`

Lint results


**No lint errors found**
</details>

---

- 我检查了 `ReaderView.loadCurrentBook()` 的 SQL：之前 `FROM book b ... WHERE book.id = ?` 使用了表别名 `b`，但 WHERE 里写成了 `book.id`，会导致该查询失败，`currentBook` 始终为 nil。这样就会出现：
  - 顶部 `topControlsView` 里 `currentBook?.title ?? ""` 为空，书名不显示；
  - 目录弹窗依赖 `if let book = currentBook`，为 nil 时走“正在加载目录...”。

- 我已修正查询条件为 `WHERE b.id = ?`，并把查询结果里的 `author`、`category` 正确赋给 `Book`，确保 `currentBook` 被填充。

- 我也做了快速的语法检查，未发现新的 linter 问题。请重新运行看看顶部书名和目录是否正常显示。

简要说明：
- 关键改动在 `ReaderView.loadCurrentBook()`：把 `WHERE book.id = ?` 改为 `WHERE b.id = ?`，并映射 `author`、`category` 字段到 `Book`。

---

_**User (2025-08-30 15:11Z)**_

阅读图书时，点击查看目录，目录是否自动定位到当前的章节呢？比如图书有100章，目前读到60章，那么打开目录后，自动定位到60章的位置。当然如果目录中的第60章要是能高亮就最好了，不能也无所谓

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Updating code structure**

I see that the original code for the search branch has duplicates. I also want to update the search `List` items to make sure they reflect highlights in a similar way. Next, I need to update the ReaderView sheet to pass `initialChapterId: currentChapter.id`. I’ll check lines 77-92 to add that parameter. Alright, let's get those edits implemented!</details></think>

---

我会先为目录视图增加“自动滚动到当前章节”的能力，并从阅读页把当前章节 id 传入，然后为匹配的章节做轻量高亮。接着我会应用这些编辑并检查是否有新的 linter 问题。

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Reviewing code changes**

I'm working on patching ChapterListView.swift, but the context doesn't match. I should read the file again to verify its content because it may differ from what I saw earlier. The apply_patch likely failed due to whitespace issues or differences. I'll use the read_file function again to ensure I have the right information. After that, I'll craft a patch to add the initialChapterId parameter and make some modifications in ReaderView.swift. Let's make sure to follow the guidelines and create a todo list for these tasks.
**Creating tasks for updates**

I’m dealing with a multi-step change that spans two files, so I’ll use todo_write to create tasks. The instructions suggest being proactive with these. I’ll set up two todos: one to update ChapterListView for initialChapterId and auto-scroll highlighting, and another to update ReaderView to pass the current chapter ID when opening the catalog. I'll mark the first task as in_progress, make the necessary edits, and check for linter errors using read_lints on both files. Time to get started!</details></think>

---

我先创建待办来跟踪这次改造，并开始实现目录自动定位与高亮；接着我会读取并编辑 `ChapterListView.swift` 与 `ReaderView.swift`。

---

Tool use: **todo_write**

## Todo List

- [-] 为 ChapterListView 添加 initialChapterId 支持并自动滚动/高亮当前章节
- [ ] 在 ReaderView 打开目录时传递当前章节 id 以启用自动定位

---

<think><details><summary>Thought Process</summary>**Executing file updates**

I'm planning to read both files and apply the necessary patches. I need to include status updates before I make any tool calls, and I'll definitely keep my todo list updated after each step. First, I'll edit ChapterListView and mark that todo as completed. Then, I'll move on to ReaderView to pass parameters and mark that todo in progress, and finally completed. I’ll also run lints on both files, but there aren't any tests available. Let's make this happen!</details></think>

---

我先读取 `ChapterListView.swift` 与 `ReaderView.swift` 的最新内容以确保编辑精准，然后实现目录自动定位与高亮，并在阅读页传入当前章节 id。

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Views/ChapterListView.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift

---

<think><details><summary>Thought Process</summary>**Implementing auto-scroll functionality**

I need to focus on adding functionality so that when opening the ChapterListView from ReaderView, it automatically scrolls to the current chapter and possibly highlights it. I noticed that ChapterListView currently doesn't support initialChapterId, so I'll have to modify it. To achieve the auto-scroll, wrapping the content in ScrollViewReader seems essential, and I’ll also assign .id to rows for easy tracking. There are some complexities with List in iOS 16+, but I'm determined to make it work!
**Adjusting ChapterListView for scrolling**

It's fine if highlighting is optional since the user mentioned it's a nice-to-have feature. I need to ensure ReaderView passes currentChapter.id to ChapterListView when presenting. For ChapterListView, I’ll add an `initialChapterId: Int? = nil` variable and an @State variable for didAutoScroll. Wrapping the body with ScrollViewReader is important so I can attempt auto-scroll after data loads, and I'll add .id to each row button. I’ll also re-apply patches carefully because I’ve faced some context mismatches before.
**Implementing ChapterListView modifications**

I need to add some row modifications, like computing isCurrent, setting foregroundColor and fontWeight, and including .id(chapter.id) for both branches. I’ll add an attemptAutoScroll method as well. It’s important to ensure the List path has similar updates. I'll preserve the file's 4-space indentation, which is crucial for readability. 

I’m preparing to make multiple smaller edits while adjusting the struct header to include the new variables and state. Wrapping the body in ScrollViewReader will also require some changes, especially since .onChange has updated in iOS 17!
**Analyzing onChange usage in ReaderView**

In the current ReaderView, they utilize `.onChange(of: pages) { oldPages, newPages in ... }`, which suggests they're using Swift 5.9 iOS 17 style with a two-argument form. This leads me to wonder if `chaptersByVolume`, being a dictionary, is Equatable. It seems it might not be Equatable unless both keys and values are Equatable. 

SwiftUI 5 requires Equatable types for .onChange, which could lead to a compile error. I think it might be safer to trigger attemptAutoScroll only in onAppear after loadData updates the state. However, since loadData is executed synchronously on the same run loop, state updates will trigger view updates afterward. I can't call attemptAutoScroll inside loadData since it requires a proxy.
**Scheduling scroll in ReaderView**

I think it’s a good idea to schedule the scroll on the main thread after a slight delay to ensure the content is fully built. Using DispatchQueue.main.asyncAfter in onAppear could work well for this. Alternatively, I can set didAutoScroll to false and call attemptAutoScroll in .onAppear, plus add .onChange for the chapters array, which is safe since our Chapter conforms to Equatable.

I’ll use the two-argument form for .onChange to maintain consistency with ReaderView. I also need to ensure there's an isCurrent property for each row, and I have to provide the attemptAutoScroll method to handle scrolling to initialChapterId when it's not nil, while updating ReaderView to include the currentChapter.id. I'll proceed with implementing this patch carefully!</details></think>

---

我会先修改 `ChapterListView` 以支持传入当前章节并自动滚动/高亮，然后更新 `ReaderView` 在打开目录时传入当前章节 id。接着我会检查语法。

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Implementing chapter scroll feature**

I need to work on a feature for the ChapterListView. The goal is to auto-scroll to the current chapter and possibly highlight it too. I tried to patch it, but it didn’t work due to context mismatch, likely from spacing differences in the file. The apply_patch tool struggled with the exact context lines needed. Instead, I can use the edit_file tool, which allows me to specify only changes. I’ll add a parameter for initialChapterId and implement the necessary changes for scrolling and highlighting.
**Updating ReaderView for chapter selection**

I need to modify the ReaderView to ensure it passes the initialChapterId, which is the currentChapter.id, to the ChapterListView. In the ReaderView.swift file, I'll update the sheet for showing the catalog. I need to add initialChapterId: currentChapter.id to the constructor. While working with the search variant, I'll ensure the ids are set and highlighted as well. For the implementation, I’ll use the edit_file tool on ChapterListView.swift, keeping my edits minimal and consistent while preserving formatting.
**Planning edits for ChapterListView**

I'm looking at the edits needed for the ChapterListView struct. First, I’ll add a variable for initialChapterId and a state variable for didAutoScroll. Then, in the body of the view, I need to wrap it in a ScrollViewReader and include appropriate actions like loading data and attempting auto-scroll on appearance and when chapters change. I’ll also update the search List to incorporate isCurrent and the chapter id. Lastly, I’ll define a private function for the auto-scroll at the bottom of the file.
**Using edit_file tool for updates**

I’ll utilize the edit_file tool to implement several changes. First, I need to adjust the struct header by adding initialChapterId and the didAutoScroll state variables. For the body, I’ll replace the entire var body content, but I can’t make arbitrary replacements. I need to identify a unique block to replace, which will be from "var body: some View {" to the end of that section. I’ll ensure to follow the rules regarding how much context to include, using // ... existing code ... for unchanged sections.
**Crafting patch for ChapterListView**

I’m planning to create a patch for the ChapterListView that includes a few major changes. First, I’ll replace the struct header to add initialChapterId and didAutoScroll, along with updating the var body section entirely. I realize I need to specify the exact lines to edit and ensure to indicate new code with // ... existing code ... comments. Additionally, I need to format the new body correctly with a ScrollViewReader and the attemptAutoScroll functionality. Lastly, I’ll ensure the ReaderView passes the correct parameters and set up the .id for both ScrollView and List components.
**Writing and applying patches**

I’m ready to write the patch for both ChapterListView and ReaderView. After completing the edits, I’ll run lints on both files to ensure everything’s working smoothly. I also need to update the TODO statuses: I’ll mark the first task as completed and the second one as pending, ensuring everything is tracked properly. Ideally, I want to apply the patches in a single batch using sequential apply_patch calls. Once both tasks are done, I’ll perform a final lint check for good measure. Let's proceed!</details></think>

---

我先在目录视图中加入自动滚动与高亮支持（接收 initialChapterId，并用 ScrollViewReader 实现），然后在阅读页打开目录时传入当前章节 id。随后我会检查语法/警告。

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Implementing feature updates**

I need to implement a feature where, when the user opens the ChapterListView from ReaderView, it auto-scrolls to the current chapter and highlights it. We previously tried to patch ChapterListView.swift, but ran into context mismatches in the apply_patch tool. After three failures, we should now use the edit_file tool. 

I'll be careful with the changes to maintain the code format, ensuring the indentation is preserved. It looks like 4 spaces are used throughout, so I’ll follow that style. Lastly, I’ll modify ReaderView.swift to pass the initialChapterId to ChapterListView.
**Modifying ChapterListView**

I need to make some updates to the ChapterListView. First, I'll add the initialChapterId: currentChapter.id to the existing code. Then, I’ll wrap it in a ScrollViewReader and set up an .id for the chapter rows to enable scrolling. I'll introduce a property for initialChapterId and a didAutoScroll state. 

When the view appears or changes, we'll call attemptAutoScroll to scroll to the target chapter. I also want to highlight the current chapter using accent color and bold weight. I must ensure the code compiles correctly, considering the use of ScrollViewReader in SwiftUI and aligning with the iOS 17 style for .onChange.
**Ensuring compatibility**

I need to maintain compatibility with earlier Swift versions while using the iOS 17 style for some elements. So, I'll add ".onChange(of: chapters) { old, new in ... }". In iOS 17, the closure signature is (oldValue, newValue), while older styles use just "(value) in". Since ReaderView already uses the iOS 17 style, it's fine for me to follow suit here.

I also want to ensure that .searchable stays outside of the ScrollViewReader. For filtered lists with non-empty searchText, I need to manage that since ScrollViewReader works only with ScrollViews. However, it can wrap a List from iOS 15 onwards. I'll keep an id for each row and use the proxy to scroll to the target id, but I may opt-out of auto-scrolling when searchText is present. That seems acceptable.
**Implementing auto-locate feature**

The user is asking for an auto-locate feature when opening the directory, assuming they won't type in a search right away. I think I’ll simplify things by attempting to auto-scroll on appear and on change, but only when searchText is empty. However, I can still call the scroll function regardless. Since I'm using ScrollViewReader to wrap the content, I must ensure that we can still call scrollTo, even if it might not work inside a List.

To enable scrolling by ID, I’ll add .id(chapter.id) to the buttons and NavigationLink rows. I also need to ensure the return types remain consistent. Now, I’ll implement the edits using the edit_file fallback, applying minimal changes while specifying precise lines with the necessary sentinel markers.
**Planning code edits**

For Swift code comments, I need to use the format // ... existing code ... to indicate unchanged sections. I have multiple edits to implement for ChapterListView.

First, I’ll add "var initialChapterId: Int? = nil" and "@State private var didAutoScroll = false" after the onSelect declaration. Second, I’ll wrap the body content in a ScrollViewReader. This will involve rewriting from "var body: some View {" to the end of the .onAppear line.

I’ll also need to insert the attemptAutoScroll function before the closing brace. Next, I must modify onAppear to call attemptAutoScroll and adjust the onChange state. Lastly, I’ll add highlight changes and .id attributes to the rows.

Since the edits are complex, replacing entire file content might seem tempting, but I'll focus on replacing key blocks while adhering to the directive of specifying precise lines for editing. This ensures we maintain proper context and follow the existing coding standards. 

After that, I have to update ReaderView.swift to pass initialChapterId as a parameter in the ChapterListView call. Finally, I'll check both files with read_lints after the edits and update my todo list accordingly, marking tasks as completed or in-progress as necessary. Let's carefully proceed!</details></think>

---

我将先在 `ChapterListView` 添加 `initialChapterId` 与自动滚动/高亮实现，然后在 `ReaderView` 打开目录时传入当前章节 id。完成后会运行一次语法/风格检查。

---

Tool use: **edit_file**


<details><summary>Edit file: /Users/zgia/program/book/BookReader/BookReader/Views/ChapterListView.swift</summary>

**Chunk 1**
Lines added: 93, lines removed: 73

```diff
@@ -9,79 +9,99 @@
      @State private var chaptersByVolume: [Int: [Chapter]] = [:]  // volumeId -> chapters
      @State private var searchText = ""
+     var initialChapterId: Int? = nil
+     @State private var didAutoScroll = false
  
      var body: some View {
-         Group {
-             if searchText.isEmpty {
-                 ScrollView {
-                     LazyVStack(
-                         alignment: .leading,
-                         pinnedViews: [.sectionHeaders]
-                     ) {
-                         ForEach(volumes) { v in
-                             Section(
-                                 header:
-                                     ZStack(alignment: .leading) {
-                                         // 提供背景以避免吸顶时文字与内容叠加
-                                         Color(.systemBackground)
-                                         VStack(alignment: .leading, spacing: 4)
-                                         {
-                                             Text(v.title).font(.headline)
-                                             if !v.summary.isEmpty {
-                                                 Text(v.summary)
-                                                     .font(.caption)
-                                                     .foregroundColor(.secondary)
-                                             }
-                                         }
-                                         .padding(.vertical, 6)
-                                         .padding(.horizontal)
-                                     }
-                             ) {
-                                 ForEach(chaptersByVolume[v.id] ?? []) {
-                                     chapter in
-                                     if let onSelect = onSelect {
-                                         Button(action: { onSelect(chapter) }) {
-                                             Text(chapter.title)
-                                                 .foregroundColor(.primary)
-                                                 .padding(.horizontal)
-                                                 .padding(.vertical, 8)
-                                         }
-                                     } else {
-                                         NavigationLink(
-                                             destination: ReaderView(
-                                                 chapter: chapter
-                                             )
-                                         ) {
-                                             Text(chapter.title)
-                                                 .foregroundColor(.primary)
-                                                 .padding(.horizontal)
-                                                 .padding(.vertical, 8)
-                                         }
-                                     }
-                                 }
-                             }
-                         }
-                     }
-                 }
-             } else {
-                 List(filteredChapters) { chapter in
-                     if let onSelect = onSelect {
-                         Button(action: { onSelect(chapter) }) {
-                             Text(chapter.title)
-                                 .foregroundColor(.primary)
-                         }
-                     } else {
-                         NavigationLink(
-                             destination: ReaderView(chapter: chapter)
-                         ) {
-                             Text(chapter.title)
-                                 .foregroundColor(.primary)
-                         }
-                     }
-                 }
-             }
-         }
-         .searchable(text: $searchText)
-         .navigationTitle(book.title)
-         .onAppear { loadData() }
+         ScrollViewReader { proxy in
+             Group {
+                 if searchText.isEmpty {
+                     ScrollView {
+                         LazyVStack(
+                             alignment: .leading,
+                             pinnedViews: [.sectionHeaders]
+                         ) {
+                             ForEach(volumes) { v in
+                                 Section(
+                                     header:
+                                         ZStack(alignment: .leading) {
+                                             // 提供背景以避免吸顶时文字与内容叠加
+                                             Color(.systemBackground)
+                                             VStack(alignment: .leading, spacing: 4)
+                                             {
+                                                 Text(v.title).font(.headline)
+                                                 if !v.summary.isEmpty {
+                                                     Text(v.summary)
+                                                         .font(.caption)
+                                                         .foregroundColor(.secondary)
+                                                 }
+                                             }
+                                             .padding(.vertical, 6)
+                                             .padding(.horizontal)
+                                         }
+                                 ) {
+                                     ForEach(chaptersByVolume[v.id] ?? []) {
+                                         chapter in
+                                         let isCurrent = (initialChapterId == chapter.id)
+                                         if let onSelect = onSelect {
+                                             Button(action: { onSelect(chapter) }) {
+                                                 Text(chapter.title)
+                                                     .foregroundColor(isCurrent ? .accentColor : .primary)
+                                                     .fontWeight(isCurrent ? .semibold : .regular)
+                                                     .padding(.horizontal)
+                                                     .padding(.vertical, 8)
+                                             }
+                                             .id(chapter.id)
+                                         } else {
+                                             NavigationLink(
+                                                 destination: ReaderView(
+                                                     chapter: chapter
+                                                 )
+                                             ) {
+                                                 Text(chapter.title)
+                                                     .foregroundColor(isCurrent ? .accentColor : .primary)
+                                                     .fontWeight(isCurrent ? .semibold : .regular)
+                                                     .padding(.horizontal)
+                                                     .padding(.vertical, 8)
+                                             }
+                                             .id(chapter.id)
+                                         }
+                                     }
+                                 }
+                             }
+                         }
+                     }
+                 } else {
+                     List(filteredChapters) { chapter in
+                         let isCurrent = (initialChapterId == chapter.id)
+                         if let onSelect = onSelect {
+                             Button(action: { onSelect(chapter) }) {
+                                 Text(chapter.title)
+                                     .foregroundColor(isCurrent ? .accentColor : .primary)
+                                     .fontWeight(isCurrent ? .semibold : .regular)
+                             }
+                             .id(chapter.id)
+                         } else {
+                             NavigationLink(
+                                 destination: ReaderView(chapter: chapter)
+                             ) {
+                                 Text(chapter.title)
+                                     .foregroundColor(isCurrent ? .accentColor : .primary)
+                                     .fontWeight(isCurrent ? .semibold : .regular)
+                             }
+                             .id(chapter.id)
+                         }
+                     }
+                 }
+             }
+             .searchable(text: $searchText)
+             .navigationTitle(book.title)
+             .onAppear {
+                 loadData()
+                 attemptAutoScroll(proxy)
+             }
+             .onChange(of: chapters) { _, _ in
+                 attemptAutoScroll(proxy)
+             }
+         }
      }
  
```

**Chunk 2**
Lines added: 12, lines removed: undefined

```diff
@@ -112,4 +132,16 @@
          }
      }
+ 
+     private func attemptAutoScroll(_ proxy: ScrollViewProxy) {
+         guard !didAutoScroll, let targetId = initialChapterId else { return }
+         let exists = chapters.contains(where: { $0.id == targetId })
+         guard exists else { return }
+         DispatchQueue.main.async {
+             withAnimation(.easeInOut(duration: 0.2)) {
+                 proxy.scrollTo(targetId, anchor: .top)
+             }
+             didAutoScroll = true
+         }
+     }
  }
  
```

</details>

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift
@@
             .sheet(isPresented: $showCatalog) {
                 NavigationView {
                     if let book = currentBook {
                         ChapterListView(
                             book: book,
+                            initialChapterId: currentChapter.id,
                             onSelect: { ch in
                                 currentChapter = ch
                                 loadContent(for: ch)
                                 showCatalog = false
                             }
                         )
                     } else {
                         Text("正在加载目录...")
                     }
                 }
             }
*** End Patch
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 2 files</summary>
      
Lint paths:

- `/Users/zgia/program/book/BookReader/BookReader/Views/ChapterListView.swift`
- `/Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift`

Lint results


**No lint errors found**
</details>

---

Tool use: **todo_write**

## Todo List

- [x] 为 ChapterListView 添加 initialChapterId 支持并自动滚动/高亮当前章节
- [x] 在 ReaderView 打开目录时传递当前章节 id 以启用自动定位

---

我已实现目录自动定位与轻量高亮，并确保从阅读页传入当前章节 id。

- 目录自动定位与高亮
  - `ChapterListView` 新增 `initialChapterId` 参数和自动滚动逻辑，使用 `ScrollViewReader` 在数据加载后滚动到该章节位置。
  - 当前章节的条目文字使用强调色与半粗体显示，便于辨识。
- 阅读页传参
  - `ReaderView` 打开目录时，传入 `initialChapterId: currentChapter.id`，列表会自动定位。
- 语法/风格检查
  - 已通过本地 linter 检查，无新增问题。

你现在打开目录时，会自动滚到当前章节（如第60章），且该行有轻量高亮效果。

---

_**User (2025-08-30 15:11Z)**_

Argument 'onSelect' must precede argument 'initialChapterId'

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Fixing parameter order**

I need to fix the parameter order in the function call. The error indicates that the 'onSelect' argument must come before 'initialChapterId.' In Swift, the parameter order does matter in initializers. While it's generally flexible once you specify argument labels, trailing closures must always be the last argument. I see now that I've treated 'onSelect' incorrectly as a trailing closure, while it's actually specified among the parameters.
**Analyzing trailing closure usage**

I think Swift might still prefer using trailing closures. The error message indicates that 'onSelect' must come before 'initialChapterId'. This suggests that the function signature likely has 'onSelect' listed first, possibly with a default value. While argument order can be flexible in Swift when using labels, SwiftUI's function builder might interpret 'onSelect' as a trailing closure if it's placed after other arguments. However, we did use a label, so the error is perplexing. Let’s check the ChapterListView signature to clarify.
**Clarifying initializer parameter order**

I see now that because 'onSelect' was declared before 'initialChapterId,' Swift expects the parameter order to follow this sequence: book, onSelect, initialChapterId, and others. However, properties marked with @State are private and don’t appear in the memberwise initializer since they come with default values and property wrappers. This means the initializer only includes stored properties without default values. Hence, the error arises because Swift requires that the closure must precede 'initialChapterId,' and you can't just reorder labeled arguments in function calls.
**Reordering parameters in calls**

I need to reorder the parameters at the call site, placing 'onSelect' before 'initialChapterId' in the ChapterListView creation. I'll fix this in ReaderView like this:

ChapterListView(
  book: book,
  onSelect: { ch in ... },
  initialChapterId: currentChapter.id
)

I also need to check other call sites, including potential instances in the BookListView or any references from ReaderSettings. I can apply the patch again since it worked before, and I should remember to perform a status update note before calling the tool and run lints after making these changes.</details></think>

---

我会把 `ReaderView` 中调用 `ChapterListView` 的参数顺序调整为先传 `onSelect` 再传 `initialChapterId`，以消除编译错误，并快速检查一次语法。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift
@@
                     if let book = currentBook {
                         ChapterListView(
                             book: book,
-                            initialChapterId: currentChapter.id,
                             onSelect: { ch in
                                 currentChapter = ch
                                 loadContent(for: ch)
                                 showCatalog = false
-                            }
+                            },
+                            initialChapterId: currentChapter.id
                         )
                     } else {
                         Text("正在加载目录...")
                     }
                 }
*** End Patch
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 1 file</summary>
      
Lint paths:

- `/Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift`

Lint results


**No lint errors found**
</details>

---

已调整参数顺序为先 `onSelect` 后 `initialChapterId`，编译错误应已消除；本地语法检查通过。

---

