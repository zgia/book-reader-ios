<!-- Generated by SpecStory -->

<!-- cursor Session be6de37d-7f37-4878-bf04-4ea35a9f01ad (2025-10-07 01:35Z) -->

# 优化阅读页内容加载体验 (2025-10-07 01:35Z)

_**User (2025-10-07 01:25Z)**_

从图书列表页@BookListView.swift 进入阅读页@ReaderView.swift 后，由于加载内容的缘故。会出现屏幕右侧是白色的情况，然后再刷新为章节内容。请改成，从图书列表页进入阅读页后，先显示一个内容框架结构，等章节内容加载后，再显示章节内容。这样就不会出现半个屏幕是白色的情况了。注意：只是从图书列表页进入阅读页才这么处理，切换上下章节时，保持原样

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Implementing content loading changes**

I realize we need to address the issue where transitioning from BookListView to ReaderView results in an empty space on the right due to pages being empty. To improve user experience, we're aiming to add a skeleton placeholder that displays while content loads, but this should only happen when entering from BookListView. For other transitions, like chapter switching, we’ll retain the original behavior. 

I’m thinking of passing a flag to indicate the navigation source and showing the skeleton overlay accordingly. It's essential to clarify how this plays out for other entry points as well.
**Improving navigation and skeleton display**

Currently, the navigation from BookListView to ReaderView uses a NavigationLink that sets the destination based on whether there’s a starting chapter. We need to focus on implementing a new initializer parameter in ReaderView called `showInitialSkeleton`, which defaults to false. 

This will only set to true when navigating from BookListView. The skeleton will be a simple shimmer placeholder that mimics a page layout with top and bottom controls. I’ll utilize a ZStack to toggle the skeleton view based on the loading state, ensuring it disappears once the content is ready.
**Addressing loading view and skeleton implementation**

During the initial load, before the pages are generated, the ScrollView shows a loading view that displays the text "reading.loading." The white space on the right could result from the left and right preview views or an overlay. To enhance the user experience, I plan to implement a skeleton layout with placeholders for titles and text, but only for the initial entry from BookListView. 

I’ll create a state variable, `isInitialEntry`, which will be set to true only when entering from BookListView. In ReaderView, the skeleton will show until the pages are loaded, disappearing once they are ready. I'll consider adding a conditional view for better management.
**Implementing state management in ReaderView**

In SwiftUI, I can manage state with a `let` property or a state variable. For the `ReaderView`, I'll set up a boolean property to indicate if the entry is from BookListView. 

In the initializer, I'll have a parameter `isInitialFromBookList`, defaulting to false. When the view appears, if this parameter is true, I’ll display the initial scaffold. Once the pages are loaded, I need to hide the scaffold but ensure it doesn't hide during chapter switching or prefetching, only triggering on the initial load.
**Implementing skeleton and layout adjustments**

While displaying the skeleton, I need to keep computing the pages but hide the ScrollView, making it invisible. The skeleton will overlay to disguise any white space, covering the content area and possibly hiding left and right preview views to enhance visibility. 

I’ll create a skeleton view using a VStack with rectangles to act as placeholders. The skeleton should appear only on the initial entry from BookListView and disappear once the pages are ready. Additionally, I'll adjust how changes in pages are handled to ensure the skeleton doesn’t remain visible unnecessarily. 

We'll proceed with modifications to both the ReaderView and BookListView to incorporate these features smoothly. I'll also set up a system to track progress and make sure to manage multiple overlays carefully.
**Running lint and preparing commit message**

I realize we need to run lints on edited files, although no specific tool exists for that. Using `read_lints` sounds like the way to go since it's recommended. I should also generate a Chinese Git commit message as part of my responsibilities. 

This commit message should reflect the updates made in the code, specifically for `ReaderView` and `BookListView`. I’ll need to implement the necessary code changes and then present the user with a relevant commit message snippet. 

Let’s focus on applying the patches to those files based on the outlined changes.</details></think>

---

我准备在 `ReaderView.swift` 中新增“首次从书籍列表进入时的骨架占位视图”，并在 `BookListView.swift` 的导航处传入标记参数。接下来我会：
- 修改 `ReaderView` 的初始化签名与状态，添加骨架视图 overlay，并在内容加载完成时自动隐藏；
- 在 `BookListView` 的 `NavigationLink` 中传入 `isInitialFromBookList: true`。
完成后我会生成一条符合规范的中文 Git 提交信息。

---

Tool use: **todo_write**

## Todo List

- [-] 在 ReaderView 增加首次进入骨架占位视图并控制显示/隐藏
- [ ] 从 BookListView 进入 ReaderView 时传入首次进入标记参数

---

<think><details><summary>Thought Process</summary>**Implementing content skeleton**

I’m thinking we need to make a change regarding the ReaderView to show a content framework skeleton while loading. This should only happen when coming from the BookListView; navigating between chapters shouldn’t trigger it. Currently, when the content is empty, the ScrollView shows a loading view, but there's a right-side white space issue likely caused by layout or offset settings. The user wants a placeholder skeleton layout instead of that white space. Now, I need to figure out how to detect the navigation from BookListView.
**Setting up skeleton in ReaderView**

I'm thinking of passing a flag when initializing the ReaderView to indicate if it’s being accessed from the BookListView. I’ll modify the initialization to include a parameter for this. Inside ReaderView, I'll add a state variable to control the skeleton display, hiding it once content loads. It's crucial to ensure that the skeleton only appears on the initial load from BookListView, not when switching chapters. I’ll implement a UI skeleton with gray bars to represent paragraphs and the title until the chapter content is ready to be displayed.
**Clarifying navigation sources for ReaderView**

I need to ensure that the skeleton in the ReaderView only appears when navigating specifically from the BookListView, while other navigation sources like Favorites or ChapterList should retain their normal behavior. I’ll modify the `BookListView.swift` file to pass the new flag when creating the ReaderView. I'll change the NavigationLink to include the flag when initializing ReaderView. Additionally, I should search the codebase to ensure that ReaderView is not being called from other locations, using both grep and codebase search tools as needed.
**Updating files for ReaderView**

I’m planning to run parallel searches with both grep and codebase_search to find all instances of ReaderView initialization. I’ll edit two specific files, keeping track of the TODO statuses as I work. In `ReaderView.swift`, I'll add a stored property to indicate whether it's initialized from the BookListView, defaulting to false so that other usages remain unaffected. The skeleton overlay will be shown only when loading content for the initial view. I need to set the state variable for showInitialSkeleton and ensure it's hidden once the content is ready, possibly using SwiftUI shapes for the skeleton overlay.
**Creating skeleton view and managing changes**

I’m considering using the `.redacted` modifier for placeholders in iOS 15. However, since it needs actual text, I might go for a simpler skeleton structure instead. I’ll design a `SkeletonPageView` with tinted rectangles to simulate the page layout while keeping dark mode in mind. It's essential to ensure this skeleton only appears when navigating from the BookListView with empty pages. I’ll also update the `BookListView` to pass the necessary flag and prepare a commit message in Chinese according to the workspace rules, while managing lints and applying changes carefully. Finally, I’ll run a parallel grep to identify other uses of `ReaderView`.</details></think>

---

我将先查找项目中 `ReaderView` 的所有初始化调用位置，确保只在 `BookListView` 处传入“首次进入标记”，然后编辑 `ReaderView.swift` 增加骨架占位视图逻辑，并在内容加载完成后隐藏。接下来我会并行搜索并开始编辑文件。

---

Tool use: **grep**

<details>
<summary>Grep for "ReaderView\(" in "/Users/zgia/program/projects/zgia/BookReader" • 3 matches</summary>

Output mode: content


| Content | Line |
|------|------|
| `ReaderView(chapter: startChapter)` | L192 |
| `destination: ReaderView(` | L74 |
| `destination: ReaderView(chapter: chapter)` | L115 |


</details>

---

Tool use: **grep**

---

Tool use: **grep**

<details>
<summary>Grep for "struct ReaderView: View" in "/Users/zgia/program/projects/zgia/BookReader" • 1 match</summary>

Output mode: content


| Content | Line |
|------|------|
| `struct ReaderView: View \{` | L4 |


</details>

---

<think><details><summary>Thought Process</summary>**Implementing skeleton overlay**

I'm considering implementing a skeleton overlay to show while the pages are loading. The ReaderView loads content when it appears. The issue of a white area seems connected to the ScrollView with an offset and empty pages. It sounds like users are encountering a problem where they see a white right side before refreshing content when they enter from the BookListView. I’m thinking the skeleton approach can help with a minimal overlay—maybe a shimmering placeholder view shaped like the content lines.
**Implementing skeleton view logic**

I want to create a state variable, `showInitialSkeleton`, to manage the display of a skeleton overlay. It could be based on whether it’s the initial load from the BookList and if loading is in progress. I’m thinking about using a VStack for the placeholder titles and lines using a redacted style. The skeleton should only show until the content loads for the first time, and I’ll hide it when the pages become non-empty. I’ll also need to consider how to set this state properly in the initializer.
**Setting skeleton view logic**

I need to set the initial value of `showInitialSkeleton` as a State variable with `_showInitialSkeleton = State(initialValue: isInitialFromBookList)`. For displaying the skeleton, I plan to overlay it in a ZStack while `showInitialSkeleton` is true, which will help hide the white areas as the main content loads.

When the pages are updated, I should turn off the skeleton. I can do this in the `onChange(of: pages)` closure by setting `showInitialSkeleton` to false if it's currently true and the new pages are not empty. I want to ensure the variable is accessible within that closure.
**Implementing skeleton view enhancements**

I recognize that if content is cached and we load pages quickly, the pages assignment will trigger the `onChange`, which is a good thing. However, showing the skeleton until the pages load could lead to flickering, so I’ll animate the skeleton fade-out using `.animation(.easeInOut(duration: 0.2), value: showInitialSkeleton)`. 

The skeleton view will consist of a ScrollView with a VStack, which includes a title rectangle and several line rectangles in a reading theme color. I'll use `.redacted` for a simpler look, ensuring the overlay only shows when `showInitialSkeleton` is true. This logic should apply only if it's the initial load from the book list.
**Updating skeleton overlay logic**

I need to declare `isInitialFromBookList` as a private property and initialize it to false in the `ReaderView`. I'll modify the `BookListView` to pass `isInitialFromBookList: true` when linking to `ReaderView`. This involves updating the initializer in `ReaderView` to accept this parameter. 

I'll ensure we hide the skeleton overlay in the `onChange(of: pages)` by setting `showInitialSkeleton` to false when new pages are loaded. The skeleton view function will be created to mimic the content frame, showing a filled VStack that spans the entire width. I want to integrate this overlay carefully within the existing layout while maintaining performance and avoiding gesture collisions. Finally, I'll perform code edits using the appropriate tool.
**Managing file edits and patches**

I need to ensure I read both `ReaderView.swift` and `BookListView.swift` using `read_file` before applying any patches since I haven't done that recently. The file is large, so I want to avoid potential mismatches. The `apply_patch` tool is recommended, but it could get complicated, so I'll prepare by reading both files first.

I'll be adding properties and modifying the initializer in `ReaderView`, also including an overlay for the skeleton view. Changes will be applied carefully to maintain structure, and I'll update `BookListView` accordingly. Once edits are made, I'll run lint checks on the modified files to ensure everything is in order.
**Updating todos and preparing commits**

I need to update my todos: I'll mark the Reader skeleton task as completed and set the BookList flag todo to in progress. Once I finish the edits, I can mark it as completed. The Git commit message should be in Chinese, but since the tool can't commit, I need to generate the appropriate commit message content.

I’ll also ensure to include status updates before any tool calls and include a summary for clarity. Let's run `functions.read_file` to read the contents of both files for editing.</details></think>

---

我将并行读取 `ReaderView.swift` 和 `BookListView.swift` 以确认最新内容，然后进行代码编辑，添加首次进入骨架视图与传参。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/BookReader/BookReader/Views/ReaderView.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/BookReader/BookReader/Views/BookListView.swift

---

<think><details><summary>Thought Process</summary>**Implementing skeleton view in ReaderView**

I'm working on making the skeleton view visible only when navigating from BookListView to ReaderView during the initial load. Currently, ReaderView shows a contentScrollView, but there's this annoying white space on the right when the pages are empty. We want to display a skeletal structure for the pages instead of that white space. It seems the white area may be from the rightPreviewView or drag offsets, but there shouldn't be any offsets on initial load.
**Implementing skeleton view on entry**

I need to show a content frame skeleton when entering ReaderView from BookListView. To do this, I plan to pass a flag, `isInitialFromBookList`, when navigating. This means modifying the current ReaderView initializer to accept a new parameter. I'll create a state variable called `showInitialSkeleton` to control the overlay display. The skeleton view will be added above the contentScrollView, featuring placeholder rectangles with a shimmering effect. I want this skeleton-only behavior on the initial entry to improve user experience.
**Managing skeleton view logic**

I need to set `showInitialSkeleton` based on `isInitialFromBookList`. When the pages are computed and displayed, I'll hide the skeleton by setting `showInitialSkeleton` to false. If cached content is present, we can also set it to false earlier. I want to ensure the skeleton only shows when navigating from BookListView, not during chapter switching. This means I won’t adjust the skeleton visibility when moving between chapters. I should also check ChapterListView, where ReaderView is called, to confirm if skeleton should display there.
**Updating ReaderView initialization**

I need to make sure I don't interrupt other initializations. First, I will update the ReaderView initializer to accept `isInitialFromBookList`. I’ll save this value as a private constant. Then, I’ll create a state variable, `showInitialSkeleton`, and set it based on `isInitialFromBookList`. However, property wrappers can't be assigned from init, so I’ll use State to set the initial value. For the body overlay, I'll add a skeleton view that allows background interactions but keeps controls hidden until everything is loaded, showing skeletons for both top and bottom controls.
**Constructing the skeleton view**

The spec suggests showing a framework structure, possibly with placeholder paragraphs and titles. I need to create a central skeleton view for the page. This involves defining a `skeletonContentView` with placeholder rectangles for the title and content lines. I'll ensure that when the pages are empty, the contentScrollView shows this skeleton instead of a loading view. I’ll adjust the initialization parameters for ReaderView and implement logic to hide the skeleton appropriately once the content loads. The skeleton should fill the entire scroll area while maintaining the reading settings for color and spacing.
**Computing width fractions and updates**

I’m setting up width fractions like [0.95, 0.9, 0.92, etc.] and calculating width using `geo.size.width * fraction` while accounting for a padding of 32. The frames will be set to this calculated width minus the padding, along with a height relative to the font size. I’ll create three sets of paragraphs with spacing to keep the code readable but effective. I'll need to modify BookListView to include the new parameter in ReaderView, ensuring everything compiles properly. Lastly, I’ll apply the necessary patches, update the todo list, and follow up with status updates.</details></think>

---

我将开始对 `ReaderView.swift` 添加“首次进入骨架视图”与新初始化参数，并在 `BookListView.swift` 的导航处传入该参数，随后检查可能的语法/风格问题。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/BookReader/BookReader/Views/ReaderView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: /Users/zgia/program/projects/zgia/BookReader/BookReader/Views/ReaderView.swift
@@
-struct ReaderView: View {
+struct ReaderView: View {
@@
     @State private var showEdgeAlert: Bool = false
     @State private var edgeAlertMessage: String = ""
 
-    init(chapter: Chapter) {
-        _currentChapter = State(initialValue: chapter)
-    }
+    // 仅用于从书籍列表首次进入时显示骨架占位，章节切换不使用
+    @State private var showInitialSkeleton: Bool = false
+
+    init(chapter: Chapter, isInitialFromBookList: Bool = false) {
+        _currentChapter = State(initialValue: chapter)
+        _showInitialSkeleton = State(initialValue: isInitialFromBookList)
+    }
@@
-                contentScrollView(geo: geo)
+                contentScrollView(geo: geo)
@@
             .onAppear {
@@
                 screenSize = geo.size
 
                 loadContent(for: currentChapter)
                 loadCurrentBook()
                 updateAdjacentRefs()
@@
             }
*** End Patch
```

---

<think><details><summary>Thought Process</summary>**Implementing skeleton overlay logic**

I need to incorporate the skeleton overlay logic so it shows the content frame UI when transitioning from the BookList until the pages fully load. The user prefers to avoid any white spaces on the right side, so we can display a skeleton with gray lines for chapter titles and paragraphs, along with a background color. This should only appear during the initial load, not on chapter switches. I’ll set the `showInitialSkeleton` state to false once the content is loaded.
**Adjusting ScrollView skeleton logic**

In the ScrollView, I need to ensure that when the pages are empty and `showInitialSkeleton` is true, the skeleton appears; otherwise, it should show the loading view. I suspect the white area on the right is due to how `background(reading.backgroundColor)` interacts with the safe area or offset settings. To address this, I’ll implement a skeleton view displaying a structure with a title bar and tinted rectangular placeholders, matching the theme without excessive shimmer. This should fill the width minus margins and sit within the same container as the actual content, so it doesn't leave any half-white space. I'll add the skeleton overlay using a ZStack to show it before the content loads, and hide it once the pages are loaded.
**Implementing skeleton overlay adjustments**

I need to add a skeleton overlay near the content area using a ZStack after the rightPreviewView. It might be simpler to apply the overlay to the overall view and center it. If I keep the skeleton in the content area, I’ll include a branch in the contentScrollView. Instead of showing the loading view when the pages are empty, I’ll change it to show the skeleton if `showInitialSkeleton` is true. This requires multiple updates, including creating a skeletonView function, modifying the contentScrollView, and updating the BookListView to pass the necessary flag for linking. Lastly, I’ll make sure to generate a Chinese git commit message to comply with the workspace rules.
**Running lints and implementing the skeleton view**

I need to make sure to run the lints tool, specifically using `read_lints` on the edited files once the updates are done. After that, I'll implement the skeleton view as a private variable, creating a ScrollView with a LazyVStack. I want the skeleton to match the existing paddings so it occupies the whole width, avoiding any white space. The title placeholder will be roughly 60% wide and have multiple paragraph lines with variable widths. I'll define a function for paragraph lines and use RoundedRectangles with specific heights and corner radii, ensuring I follow the high-verbosity naming convention without importing new frameworks.</details></think>

---

我将更新 ReaderView 骨架视图逻辑与 BookListView 的参数传递，并在保存后运行静态检查。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/BookReader/BookReader/Views/ReaderView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: /Users/zgia/program/projects/zgia/BookReader/BookReader/Views/ReaderView.swift
@@
     @ViewBuilder
     private func contentScrollView(geo: GeometryProxy) -> some View {
         // 中间：当前章节
         ScrollViewReader { proxy in
             ScrollView {
-                if !pages.isEmpty {
+                if !pages.isEmpty {
                     LazyVStack(alignment: .leading, spacing: 0) {
                         ForEach(pages.indices, id: \.self) { idx in
                             pageView(pageIndex: idx)
                                 .id(pageAnchorId(idx))
                         }
                     }
                 } else {
-                    loadingView
+                    if showInitialSkeleton {
+                        initialSkeletonView
+                    } else {
+                        loadingView
+                    }
                 }
             }
             .background(reading.backgroundColor)
             .scrollIndicators(isHorizontalSwiping ? .hidden : .visible)
             .id(currentChapter.id)
             .offset(x: dragOffset)
             .onChange(of: pages) { oldPages, newPages in
                 Log.debug(
                     "📖 onChange pages: old=\(oldPages.count) new=\(newPages.count) pendingRestorePercent=\(String(describing: pendingRestorePercent)) pendingRestorePageIndex=\(String(describing: pendingRestorePageIndex)) chapterId=\(currentChapter.id)"
                 )
                 guard !newPages.isEmpty else {
                     Log.debug("📖 onChange pages: pages empty, skip")
                     return
                 }
+                if showInitialSkeleton { showInitialSkeleton = false }
                 // 仅当目标章节就是当前章节时才应用恢复
                 let shouldApplyRestore =
                     (pendingRestoreChapterId == nil)
                     || (pendingRestoreChapterId == currentChapter.id)
                 guard shouldApplyRestore else {
@@
     }
@@
     private func loadContent(for chapter: Chapter) {
         // 命中缓存则直接返回，避免阻塞主线程
         if let cachedContent = contentCache[chapter.id],
             let cachedParas = paragraphsCache[chapter.id]
         {
@@
             if let cachedPages = pagesCache[chapter.id] {
                 Log.debug(
                     "📚 use cached pages count=\(cachedPages.count)",
                     category: .reader
                 )
                 pages = cachedPages
+                if showInitialSkeleton { showInitialSkeleton = false }
             } else {
                 let txt = cachedContent.txt ?? ""
                 Log.debug(
                     "📚 paginate cached content length=\(txt.count)",
                     category: .pagination
                 )
                 let perfPg = PerfTimer(
                     "paginate.cached",
                     category: .performance
                 )
                 let newPages = paginate(
                     text: txt,
                     screen: geoSize(),
                     fontSize: CGFloat(reading.fontSize),
                     lineSpacing: CGFloat(reading.lineSpacing)
                 )
                 pages = newPages
                 pagesCache[chapter.id] = newPages
+                if showInitialSkeleton && !newPages.isEmpty { showInitialSkeleton = false }
                 perfPg.end(
                     extra: "chapterId=\(chapter.id) pages=\(newPages.count)"
                 )
             }
             return
         }
@@
                 content = fetched
                 paragraphs = computedParas
                 contentCache[chapterId] = fetched
                 paragraphsCache[chapterId] = computedParas
                 pages = computedPages
                 pagesCache[chapterId] = computedPages
+                if showInitialSkeleton && !computedPages.isEmpty {
+                    showInitialSkeleton = false
+                }
                 updateAdjacentRefs()
                 prefetchAroundCurrent()
                 tApply.end()
                 perfAll.end(extra: "chapterId=\(chapterId)")
             }
         }
     }
@@
     private var loadingView: some View {
         Text(String(localized: "reading.loading"))
             .font(.system(size: reading.fontSize))
             .foregroundColor(reading.textColor)
             .padding()
     }
+
+    // 首次从书籍列表进入时的骨架占位视图（避免右侧白屏）
+    private var initialSkeletonView: some View {
+        // 参考真实排版的内边距与行距，确保进入时版式稳定
+        ScrollView {
+            LazyVStack(alignment: .leading, spacing: 0) {
+                // 第一页骨架
+                VStack(alignment: .leading, spacing: reading.paragraphSpacing) {
+                    // 章节标题骨架
+                    HStack { Spacer() }
+                        .frame(height: max(20, reading.fontSize * 1.2))
+                        .frame(maxWidth: .infinity)
+                        .overlay(
+                            RoundedRectangle(cornerRadius: 6)
+                                .fill(reading.textColor.opacity(0.15))
+                                .frame(width: geoSize().width * 0.5)
+                        )
+                        .padding(.top, chapterTitleTopPadding)
+                        .padding(.bottom, chapterTitleBottomPadding)
+
+                    // 若干段落骨架
+                    ForEach(0..<6, id: \.self) { idx in
+                        let widthFactor: CGFloat = idx % 3 == 0 ? 0.95 : (idx % 3 == 1 ? 0.85 : 0.75)
+                        RoundedRectangle(cornerRadius: 4)
+                            .fill(reading.textColor.opacity(0.12))
+                            .frame(
+                                width: geoSize().width * widthFactor,
+                                height: max(12, reading.fontSize * 0.9)
+                            )
+                    }
+                }
+                .padding(.horizontal)
+                .padding(.vertical, 8)
+
+                // 第二页骨架（少量行，避免过度渲染）
+                VStack(alignment: .leading, spacing: reading.paragraphSpacing) {
+                    ForEach(0..<4, id: \.self) { idx in
+                        let widthFactor: CGFloat = idx % 2 == 0 ? 0.9 : 0.7
+                        RoundedRectangle(cornerRadius: 4)
+                            .fill(reading.textColor.opacity(0.12))
+                            .frame(
+                                width: geoSize().width * widthFactor,
+                                height: max(12, reading.fontSize * 0.9)
+                            )
+                    }
+                }
+                .padding(.horizontal)
+                .padding(.vertical, 8)
+            }
+        }
+        .background(reading.backgroundColor)
+        .scrollIndicators(.hidden)
+    }
*** End Patch
```

---

<think><details><summary>Thought Process</summary>**Processing patch details**

The user didn't request to commit just yet, so I need to generate the commit message later. According to the developer instructions, I still need to push forward until everything’s resolved. I’ll patch the BookListView and run read_lints on both elements to check for style issues. It's essential to include a status update before making any tool calls, and I'll make sure to proceed with applying the patch to BookListView.</details></think>

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/BookReader/BookReader/Views/BookListView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: /Users/zgia/program/projects/zgia/BookReader/BookReader/Views/BookListView.swift
@@
         NavigationLink {
             if let startChapter = startingChapter(for: bookRow) {
-                ReaderView(chapter: startChapter)
+                ReaderView(chapter: startChapter, isInitialFromBookList: true)
             } else {
                 VStack(spacing: 12) {
                     Text(
                         String(
                             localized:
*** End Patch
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 2 files</summary>
      
Lint paths:

- `/Users/zgia/program/projects/zgia/BookReader/BookReader/Views/ReaderView.swift`
- `/Users/zgia/program/projects/zgia/BookReader/BookReader/Views/BookListView.swift`

Lint results


**No lint errors found**
</details>

---

Tool use: **todo_write**

## Todo List

- [x] 在 ReaderView 增加首次进入骨架占位视图并控制显示/隐藏
- [x] 从 BookListView 进入 ReaderView 时传入首次进入标记参数

---

已完成：我在 `ReaderView` 增加了“首次从书籍列表进入时的骨架占位视图”，并在 `BookListView` 的导航处传入标记参数，仅在从列表进入时显示骨架；切换上下章节保持原有行为。

- 关键改动
  - `ReaderView` 新增参数与状态：`init(chapter:isInitialFromBookList:)`、`showInitialSkeleton`。从缓存或分页完成后会置为 false。
  - 在 `contentScrollView` 中，当 `pages` 为空且 `showInitialSkeleton` 为 true 时，展示 `initialSkeletonView`（模拟标题与段落占位，背景为阅读背景色），避免右侧白屏。
  - `BookListView` 的 `NavigationLink` 改为传入 `isInitialFromBookList: true`，确保只在列表进入时使用骨架。

- 受影响文件
  - `BookListView.swift`
  - `ReaderView.swift`

- 行为说明
  - 从书籍列表进入：先显示内容框架骨架，章节加载完成即切换为真实内容。
  - 上下章节切换：仍使用原动画与加载逻辑，不显示骨架。

Git 提交信息:
```
feat(reader): 从书籍列表进入阅读页时显示骨架占位以避免白屏

- ReaderView 支持 isInitialFromBookList 标记并新增骨架占位视图
- BookListView 导航传入标记，仅首次进入显示骨架
- 保持章节切换时的原有加载与动画行为

关闭右侧白屏问题，提升首帧体验
```

---

