<!-- Generated by SpecStory -->

<!-- cursor Session a3ad2085-2e9e-4b91-aef4-bc905fc82122 (2025-09-06 01:22Z) -->

# 添加图书阅读更新时间功能 (2025-09-06 01:22Z)

_**User (2025-09-06 01:22Z)**_

@ReaderView.swift 我想添加一个功能，即进入阅读页，有滑动屏幕阅读时，就会更新图书的updatedat字段，表示最后的更新时间，如图书被读了。

然后图书列表按照updatedat排序，就能把常阅读的数放在最前面

---

_**Assistant (gpt-5)**_



---

我先快速查看数据模型、数据库管理和表结构，找出`updatedat`字段以及更新它的最佳位置；同时定位书籍列表排序逻辑，以便按`updatedat`倒序显示。随后我会在`ReaderView.swift`中于合适的交互点（如页面出现/滑动切章）触发更新时间写回数据库。

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Data/Models.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Data/Repositories.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Data/DatabaseManager.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Resources/book.sql

---

<think><details><summary>Thought Process</summary>**Implementing reading feature**

I need to implement a feature where, while reading and swiping the screen, the last read time updates in the book's record. The book list should be sorted by this timestamp to show frequently read books at the top. I noticed that Models.swift correctly defines the `updatedat` property, but Repositories.swift isn't fetching or passing it, leading to compilation issues. I need to ensure Repositories.swift retrieves this field and updates any Book instances created to include `updatedat`.
**Updating book data handling**

In ReaderView.loadCurrentBook, the current selection is missing the `updatedat` field, which will cause a compilation issue since the Book object requires it. However, the current version compiles likely due to earlier definitions. I see that Models.swift was recently modified to include `updatedat`, so I need to address this.  

My plan includes:

- Updating the repository to fetch `updatedat` and extending BookRowRecord.
- Modifying the loadCurrentBook query to include this field and providing a fallback.
- Implementing a method in DatabaseManager to update `updatedat` during reading events.
**Defining update triggers**

I need to define an update method in Repositories. Then, in ReaderView, I’ll set triggers for updates based on user actions:  

- On the `onAppear` event, I’ll call the update method when ReaderView enters.  
- For `OnPageAppear`, it should be triggered when a page scrolls within a chapter, but we also need to account for horizontal swipes between chapters.  
- I’ll make sure to update `updatedat` when navigating to adjacent chapters or on horizontal swipes.  

However, to avoid too many updates, I might throttle these updates, calling them only when the chapter changes or when certain drag thresholds are reached.
**Optimizing update frequency**

I’m thinking about how often to call the update function in ReaderView. Calling it every page could lead to too many writes, so it makes sense to update just once per minute or only on the first call of a session. To minimize impact, I’ll implement a system where we call the update in `onAppear` and also in `onPageAppear` but limit it using a `lastUpdateTime` property to avoid too frequent writes.

I’ll establish a timestamp and update if more than 30 seconds have passed since the last update or when switching chapters. I'll add a function to handle this logic and make sure to call it appropriately during the necessary events.
**Implementing update method in DatabaseManager**

The requirement is to update when "有滑动屏幕阅读时," which means while scrolling. The `onPageAppear` method will take care of vertical scrolling, while horizontal gestures already manage updates when switching chapters.

I’m planning to add a method in DatabaseManager to update the `updatedat` field for a book based on its ID. The database schema specifies `updatedat` as BIGINT, likely for seconds, so I'll proceed with that. I'll also need to adjust Repositories.BookRowRecord to include `updatedat`, as we’re using it for ordering. 

All instances of Book creation throughout the code will have to reference `updatedat`, so I’ll use grep to ensure I find every instance of Book being initialized.</details></think>

---

我将并行搜索代码中所有创建 `Book` 的位置，并查看书籍列表排序与阅读页，确保添加并调用更新 `updatedat` 的方法。随后我会实现数据库更新方法，并在 `ReaderView` 的合适事件中调用。

---

Tool use: **grep**

<details>
<summary>Grep for "Book\(" in "/Users/zgia/program/book/BookReader" • 5 matches</summary>

Output mode: content


| Content | Line |
|------|------|
| `loadCurrentBook()` | L123 |
| `private func loadCurrentBook() \{` | L668 |
| `return Book(` | L693 |
| `return Book(` | L703 |
| `let book = Book(` | L53 |


</details>

---

<think><details><summary>Thought Process</summary>**Evaluating Book Feature Implementation**

I need to implement a feature that updates the book's `updatedat` timestamp while reading, so frequently read books appear first in the list. I see that `Models.swift` defines `Book` with an `updatedat` field, but `Repositories.fetchBooks` constructs a `Book` without including it, leading to a mismatch. How is the code compiling? It seems like the `Book` itself has some default or `Codable` decoding logic, but I need to ensure `updatedat` is included in the fetch. I’ll have to adjust `Repositories` accordingly!
**Reviewing ReaderView Book Initialization**

I see that `ReaderView.loadCurrentBook()` uses direct SQL to fetch fields, returning a `Book` without the `updatedat` timestamp. The `Book` struct in `Models.swift` shows it has eight fields including `updatedat`, while the initializations in `ReaderView` only account for seven, which doesn't match. There’s clearly an inconsistency. If `updatedat` was added recently, the project may not be rebuilt yet. To fix this, I need to update both `ReaderView.loadCurrentBook` and `Repositories` to include `updatedat`.
**Implementing Updatedat Functionality**

I'm planning to add a function to update the `updatedat` timestamp for books. In `DatabaseManager`, I’ll create a method to set `updatedat = currentTimeMillis` for a specific book ID. Then, in `ReaderView`, I need to call this update method on events like page appearance or during reading interactions. However, to avoid too frequent updates, I'll throttle them — maybe only update if it's been over 60 seconds since the last update or upon changing chapters. I’ll consider a memory guard to limit write frequency to every 15 seconds.
**Streamlining Update Logic**

To simplify, I’m thinking of updating `updatedat` on `onPageAppear` the first time after a page appears, and then maybe every N pages after that. In `ReaderView`, adding a state variable like `lastUpdatedAtTouchTime` could help manage time intervals. I also need to ensure that the book list sorting relies on `updatedat`. Currently, `Repositories.fetchBooks` sorts by `b.updatedat DESC`, which is great, but I need to check its integration in `BookRowRecord` and confirm where else the `Book` struct is used, like in `BookListView.swift`.</details></think>

---

我将并行读取与书籍列表和模型相关的视图文件，以确保对 `Book` 的使用与我们新增的 `updatedat` 字段一致，并查找需要更新排序或字段映射的地方。

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Views/BookListView.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Views/ChapterListView.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/book/BookReader/BookReader/Views/AppSettingsView.swift

---

<think><details><summary>Thought Process</summary>**Addressing book update feature**

I need to implement a feature that updates the `book.updatedAt` property when entering the reading page or swiping through pages. The `Repositories.swift` file already fetches books sorted by `updatedAt`, but the `Book` model includes this property. However, the `ReaderView.loadCurrentBook` function isn't including the `updatedAt` field when constructing a `Book`. It looks like there are discrepancies between how `Book` is defined and how it’s being constructed. I'll need to update both `Repositories.swift` and `ReaderView` to fix this.
**Updating book properties**

I need to ensure `updatedAt` is included in various places. First, in the `Repositories.swift`, I should add the `updatedAt` field to the `BookRowRecord` struct and adjust the SQL SELECT statement accordingly. When constructing a `Book`, I want to set the `updatedAt` field to either the fetched value or zero.

In the `ReaderView.loadCurrentBook()` function, I must also adjust the SQL selection to include `b.updatedAt`. For fallback, I think setting it to zero or the current timestamp is reasonable. Finally, I need to implement a new method in the `DatabaseManager` to update this value efficiently.
**Implementing book update method**

I see that the existing fetch functions are in `Repositories.swift`, so I can add a method called `touchBookUpdatedAt(_ bookId: Int)`. In this method, I plan to execute an SQL update to change the `updatedAt` value to the current timestamp for the specified book ID. While I could add logic to only update if the incoming timestamp is greater than the current one, I don't think that's necessary.

Now, where to trigger this update? I think it should happen in `ReaderView` whenever the page appears or when the user navigates chapters. On `onAppear` and `onPageAppear`, I’ll update the database, but I want to implement throttling to avoid frequent updates. I'll store a `lastTouchTimestamp` and only update if more than 30 seconds have passed.
**Finalizing the update strategy**

I’m considering a straightforward approach where I call the save function in `onPageAppear`, but I’ll first check if the last update was more than 60 seconds ago. The requirement mentions updating as the user reads while swiping or scrolling through pages, which also includes navigating chapters. Since `ReaderView` uses horizontal swipes for chapters and vertical scrolling for pages, I think `onPageAppear` on each page is a good event.

I also want to ensure that opening a `ReaderView` from `ChapterList` updates the `updatedAt` field. Once I save this timestamp, the `BookListView` order should reflect the new timestamp after reloading when the user navigates back. I’ll proceed with the necessary code changes, starting with the `updatedAt` property already in `BookReader/Data/Models.swift`.
**Updating book construction and methods**

I need to make several updates to ensure the `Book` constructs correctly. First, in `Repositories.swift`, I’ll add the `updatedAt` property to `BookRowRecord`, modifying the SQL to select this new column. When mapping to `Book`, I should include `updatedAt`, defaulting to zero if it's missing.

Next, in `ReaderView`, I’ll update the SQL in `loadCurrentBook` to select `updatedAt` and adjust the construction logic accordingly. I'll also implement a method called `touchCurrentBook()` and call it at key moments, like during `onAppear` and `onPageAppear`. To handle throttling properly, I’ll create a timestamp guard to avoid excessive database calls. Finally, I'll apply the necessary patches to ensure everything compiles and runs smoothly.</details></think>

---

我将更新数据访问层以支持按 `updatedat` 排序和写回时间戳：在查询结果模型与 SQL 中加入 `updatedat`，构造 `Book` 时填充该字段，并新增一个更新 `updatedat` 的函数。接着，我会在 `ReaderView` 中加入节流的“触读”逻辑，在进入页面和阅读时调用更新。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/book/BookReader/BookReader/Data/Repositories.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/Data/Repositories.swift
@@
     struct BookRowRecord: Decodable, FetchableRecord {
         let id: Int
         let title: String
         let author: String?
         let category: String?
         let latest: String?
         let wordcount: Int?
         let isfinished: Int?
+        let updatedat: Int?
     }
@@
                 var sql = """
                         SELECT b.id, b.title, a.name AS author, c.title AS category,
-                               b.latest AS latest, b.wordcount AS wordcount, b.isfinished AS isfinished
+                               b.latest AS latest, b.wordcount AS wordcount, b.isfinished AS isfinished,
+                               b.updatedat AS updatedat
                         FROM book b
                         LEFT JOIN category c ON c.id = b.categoryid
                         LEFT JOIN book_author a ON a.id = b.authorid
                     """
@@
             let book = Book(
                 id: r.id,
                 category: r.category ?? "",
                 title: r.title,
                 author: r.author ?? "",
                 latest: r.latest ?? "",
                 wordcount: r.wordcount ?? 0,
-                isfinished: r.isfinished ?? 0
+                isfinished: r.isfinished ?? 0,
+                updatedat: r.updatedat ?? 0
             )
             return BookRow(
                 book: book,
                 categoryTitle: r.category ?? "",
                 lastProgress: progressDict[r.id]
             )
         }
     }
@@
     func totalChapterCount(bookId: Int) -> Int {
         (try? dbQueue.read { db in
             try Chapter
                 .filter(Column("bookid") == bookId)
                 .fetchCount(db)
         }) ?? 0
     }
+
+    // 将某本书的 updatedat 触达为当前时间戳
+    func touchBookUpdatedAt(bookId: Int, at timestamp: Int? = nil) {
+        let ts = timestamp ?? Int(Date().timeIntervalSince1970)
+        guard let dbQueue = dbQueue else { return }
+        do {
+            try dbQueue.write { db in
+                try db.execute(
+                    sql: "UPDATE book SET updatedat = ? WHERE id = ?",
+                    arguments: [ts, bookId]
+                )
+            }
+        } catch {
+            // 静默失败即可
+        }
+    }
 }
*** End Patch
```

---

<think><details><summary>Thought Process</summary>**Considering code optimization**

I realize that onPageAppear will trigger when new chapters load, which is fine for tracking reading sessions. To ensure safety, I’ll also call onAppear. This will prevent spamming the database if the user scrolls within the same page since onPageAppear only fires for page views. It can trigger when revisiting a page, but I’ll implement throttling. I'll need to make function edits in ReaderView.swift and adjust the SQL to incorporate updatedat. Let’s also update BookListView to reload correctly.
**Reviewing navigation behavior**

I see that BookListView loads onAppear, which means it might reappear after returning, but in NavigationStack, the underlying view stays in memory without displaying. When navigating back, onAppear triggers again to loadBooks, which is good. However, if the book list is open while reading, it doesn't use navigation. We could post a Notification or use @Published to update, but that might not be necessary. I should run read_lints on the updated Repositories.swift and ReaderView.swift files and apply patches for modifications in ReaderView.swift.</details></think>

---

我将把数据库的更新时间读取与写入完善：1) 在 `ReaderView.loadCurrentBook()` 的 SQL 中选出 `updatedat` 并构造 `Book` 时填充；2) 在阅读页进入及翻页时节流更新 `book.updatedat` 字段。现在开始修改 `ReaderView.swift`。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/Views/ReaderView.swift
@@
     @State private var nextChapterRef: Chapter?
     private let prefetchRadius: Int = 3
     // 首次进入时用于恢复进度
     @State private var needsInitialRestore: Bool = true
     @State private var pendingRestorePercent: Double? = nil
     @State private var pendingRestorePageIndex: Int? = nil
+    // 触达书籍更新时间节流
+    @State private var lastBookUpdatedAtTouchUnixTime: Int = 0
@@
             .onAppear {
@@
                 prefetchAroundCurrent()
                 if needsInitialRestore {
                     restoreLastProgressIfNeeded()
                 }
+                // 进入阅读页即触达一次（节流保护）
+                touchCurrentBookUpdatedAt(throttleSeconds: 30)
             }
         }
     }
@@
     private func loadCurrentBook() {
         guard currentBook == nil else { return }
         guard let dbQueue = DatabaseManager.shared.dbQueue else { return }
         currentBook = try? dbQueue.read { db in
             let sql = """
-                    SELECT b.id, b.title, a.name AS author, c.title AS category,
-                           b.latest AS latest, b.wordcount AS wordcount, b.isfinished AS isfinished
+                    SELECT b.id, b.title, a.name AS author, c.title AS category,
+                           b.latest AS latest, b.wordcount AS wordcount, b.isfinished AS isfinished,
+                           b.updatedat AS updatedat
                     FROM book b
                     LEFT JOIN category c ON c.id = b.categoryid
                     LEFT JOIN book_author a ON a.id = b.authorid
                     WHERE b.id = ?
                 """
             if let row = try Row.fetchOne(
                 db,
                 sql: sql,
                 arguments: [currentChapter.bookid]
             ) {
                 let id: Int = row["id"]
                 let title: String = (row["title"] as String?) ?? ""
                 let author: String = (row["author"] as String?) ?? ""
                 let category: String = (row["category"] as String?) ?? ""
                 let latest: String = (row["latest"] as String?) ?? ""
                 let wordcount: Int = (row["wordcount"] as Int?) ?? 0
                 let isfinished: Int = (row["isfinished"] as Int?) ?? 0
+                let updatedat: Int = (row["updatedat"] as Int?) ?? 0
 
                 return Book(
                     id: id,
                     category: category,
                     title: title,
                     author: author,
                     latest: latest,
                     wordcount: wordcount,
-                    isfinished: isfinished
+                    isfinished: isfinished,
+                    updatedat: updatedat
                 )
             } else {
                 return Book(
                     id: currentChapter.bookid,
                     category: "",
                     title: "",
                     author: "",
                     latest: "",
                     wordcount: 0,
-                    isfinished: 0
+                    isfinished: 0,
+                    updatedat: 0
                 )
             }
         }
     }
@@
     private func onPageAppear(_ pageIndex: Int) {
         currentVisiblePageIndex = pageIndex
         let percent =
             pages.count > 1
             ? Double(pageIndex) / Double(pages.count - 1)
             : 0
         dlog(
             "📝 onPageAppear pageIndex=\(pageIndex) percent=\(percent) pages=\(pages.count) chapterId=\(currentChapter.id)"
         )
         saveProgress(percent: percent, pageIndex: pageIndex)
+        // 阅读中触达更新时间（节流）
+        touchCurrentBookUpdatedAt(throttleSeconds: 30)
     }
@@
                 if value.translation.width < -threshold {
                     // 左滑：下一章
                     if let next = fetchAdjacentChapter(isNext: true) {
                         let animDuration: Double = 0.2
                         withAnimation(.easeInOut(duration: animDuration)) {
                             dragOffset = -size.width
                         }
                         ensurePrepared(for: next) {
                             let deadline = DispatchTime.now() + animDuration
                             DispatchQueue.main.asyncAfter(deadline: deadline) {
                                 currentChapter = next
                                 loadContent(for: next)
                                 updateAdjacentRefs()
                                 prefetchAroundCurrent()
                                 // 无动画复位，避免二次滑入闪烁
                                 dragOffset = 0
+                                // 切章立即触达一次
+                                touchCurrentBookUpdatedAt(throttleSeconds: 0)
                             }
                         }
                     } else {
                         withAnimation(.easeInOut) { dragOffset = 0 }
                     }
                 } else if value.translation.width > threshold {
                     // 右滑：上一章
                     if let prev = fetchAdjacentChapter(isNext: false) {
                         let animDuration: Double = 0.2
                         withAnimation(.easeInOut(duration: animDuration)) {
                             dragOffset = size.width
                         }
                         ensurePrepared(for: prev) {
                             let deadline = DispatchTime.now() + animDuration
                             DispatchQueue.main.asyncAfter(deadline: deadline) {
                                 currentChapter = prev
                                 loadContent(for: prev)
                                 updateAdjacentRefs()
                                 prefetchAroundCurrent()
                                 // 无动画复位，避免二次滑入闪烁
                                 dragOffset = 0
+                                // 切章立即触达一次
+                                touchCurrentBookUpdatedAt(throttleSeconds: 0)
                             }
                         }
                     } else {
                         withAnimation(.easeInOut) { dragOffset = 0 }
                     }
                 } else {
                     withAnimation(.easeInOut) { dragOffset = 0 }
                 }
             }
     }
+
+    // 触达当前书籍的 updatedat（节流）
+    private func touchCurrentBookUpdatedAt(throttleSeconds: Int) {
+        let now = Int(Date().timeIntervalSince1970)
+        if throttleSeconds <= 0 || now - lastBookUpdatedAtTouchUnixTime >= throttleSeconds {
+            DatabaseManager.shared.touchBookUpdatedAt(bookId: currentChapter.bookid, at: now)
+            lastBookUpdatedAtTouchUnixTime = now
+        }
+    }
*** End Patch
```

---

<think><details><summary>Thought Process</summary>**Refining Book Struct Updates**

I earlier created the Book struct with only 6 fields and added an updatedAt parameter, but the Models.swift struct expects 7. Since the ReaderView.loadCurrentBook function wasn't using updatedAt, I had to change it. I searched for other instances where Book was constructed, found and fixed relevant lines in ReaderView.swift and Repositories. Now, I've defined DatabaseManager.touchBookUpdatedAt in Repositories, and ensured that imports for GRDB aren't necessary. Lastly, I adjusted the onAppear function calls and throttled the update times as needed.
**Improving Touch Functionality**

I realized I'm not calling the touch function; however, in the horizontalSwipeGesture path, we did add touch for both left and right swipes. The navigateToAdjacentChapter also needs to trigger touch since it uses buttons. I haven't added that yet but need to. Additionally, when changing chapters from the catalog sheet, I should touch then as well. On page appearance, touch gets triggered after pagination, but I’m considering whether it needs to be immediate rather than throttled for 30 seconds.
**Enhancing Touch Functionality in ReaderView**

I think it might be necessary to ensure the first onPageAppear doesn't trigger if there are rapid chapter jumps within 30 seconds; we want those flagged as reading. We've added immediate touch for swipe changes. For chapter selection from the catalog, I'll implement immediate touch by adding it to the onSelect closure, calling touchCurrentBookUpdatedAt with a throttle of 0. I also need to patch ReaderView.swift to include touches in navigateToAdjacentChapter and remove unnecessary toggles for showSettings and showCatalog. Let's get that done!
**Checking Repositories.swift Setup**

I need to make sure the Repositories.swift extension uses dbQueue correctly since the variable names collide. I wrote a guard statement for dbQueue, ensuring it's accessible. In the DatabaseManager extension, I have a property named dbQueue, but referencing it directly could cause issues due to overshadowing. Next, I should compile and run a linter check using read_lints on both files. Although this system doesn't compile, the linter is essential for our workspace. Let's go ahead and apply the necessary patches first.</details></think>

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/Views/ReaderView.swift
@@
                         ChapterListView(
                             book: book,
                             onSelect: { ch in
                                 currentChapter = ch
                                 loadContent(for: ch)
+                                // 从目录跳转时立即触达
+                                touchCurrentBookUpdatedAt(throttleSeconds: 0)
                                 showCatalog = false
                             },
                             initialChapterId: currentChapter.id
                         )
                     } else {
@@
             DispatchQueue.main.asyncAfter(deadline: deadline) {
                 currentChapter = target
                 loadContent(for: target)
                 updateAdjacentRefs()
                 prefetchAroundCurrent()
                 // 重置偏移（无动画），此时右侧/左侧预览已参与过滑动，不再二次滑入
                 dragOffset = 0
+                // 按钮切章也触达
+                touchCurrentBookUpdatedAt(throttleSeconds: 0)
             }
         }
     }
*** End Patch
```

---

<think><details><summary>Thought Process</summary>**Ensuring Book List Updates**

I need to make sure that the Book list reloads when the updatedAt changes. Currently, the BookListView loads the list when the view appears or when the search changes, but it might not reload automatically when returning from the ReaderView. The onAppear event typically triggers again with SwiftUI's NavigationStack, which is good, but there's no guarantee. The list should also be sorted by updatedAt when navigating back. In the ReaderView, the list isn't visible during reading, but that seems okay. Let's run the lints tool on the two files to check for any issues.</details></think>

---

我刚完成在数据层与阅读页的实现，现在先检查我改动的文件是否有新的语法或风格错误。

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 2 files</summary>
      
Lint paths:

- `/Users/zgia/program/book/BookReader/BookReader/Data/Repositories.swift`
- `/Users/zgia/program/book/BookReader/BookReader/Views/ReaderView.swift`

Lint results


**No lint errors found**
</details>

---

- 我已在数据层加入`updatedat`读写，并在阅读页触发更新：进入阅读、翻页出现、切换章节、从目录跳转都会触发，且内置30秒节流避免频繁写库。
- 书籍列表SQL已按`updatedat`倒序排序，常读书会自动排前。

变更要点
- 更新`Book`字段映射，查询增加`updatedat`：
```12:22:BookReader/Data/Repositories.swift
    struct BookRowRecord: Decodable, FetchableRecord {
        let id: Int
        let title: String
        let author: String?
        let category: String?
        let latest: String?
        let wordcount: Int?
        let isfinished: Int?
        let updatedat: Int?
    }
```
```21:47:BookReader/Data/Repositories.swift
                var sql = """
                        SELECT b.id, b.title, a.name AS author, c.title AS category,
                               b.latest AS latest, b.wordcount AS wordcount, b.isfinished AS isfinished,
                               b.updatedat AS updatedat
                        FROM book b
                        LEFT JOIN category c ON c.id = b.categoryid
                        LEFT JOIN book_author a ON a.id = b.authorid
                    """
```
```53:67:BookReader/Data/Repositories.swift
            let book = Book(
                id: r.id,
                category: r.category ?? "",
                title: r.title,
                author: r.author ?? "",
                latest: r.latest ?? "",
                wordcount: r.wordcount ?? 0,
                isfinished: r.isfinished ?? 0,
                updatedat: r.updatedat ?? 0
            )
```
- 新增触达函数，用于更新书籍`updatedat`：
```70:105:BookReader/Data/Repositories.swift
    func touchBookUpdatedAt(bookId: Int, at timestamp: Int? = nil) {
        let ts = timestamp ?? Int(Date().timeIntervalSince1970)
        guard let dbQueue = dbQueue else { return }
        do {
            try dbQueue.write { db in
                try db.execute(
                    sql: "UPDATE book SET updatedat = ? WHERE id = ?",
                    arguments: [ts, bookId]
                )
            }
        } catch {
            // 静默失败即可
        }
    }
```
- `ReaderView`加载书信息时填充`updatedat`，并在阅读交互中调用触达：
```668:714:BookReader/Views/ReaderView.swift
                    SELECT b.id, b.title, a.name AS author, c.title AS category,
                           b.latest AS latest, b.wordcount AS wordcount, b.isfinished AS isfinished,
                           b.updatedat AS updatedat
...
                let updatedat: Int = (row["updatedat"] as Int?) ?? 0
...
                    isfinished: isfinished,
                    updatedat: updatedat
```
```54:61:BookReader/Views/ReaderView.swift
    @State private var pendingRestorePageIndex: Int? = nil
    // 触达书籍更新时间节流
    @State private var lastBookUpdatedAtTouchUnixTime: Int = 0
```
```117:130:BookReader/Views/ReaderView.swift
                if needsInitialRestore {
                    restoreLastProgressIfNeeded()
                }
                // 进入阅读页即触达一次（节流保护）
                touchCurrentBookUpdatedAt(throttleSeconds: 30)
```
```805:815:BookReader/Views/ReaderView.swift
        saveProgress(percent: percent, pageIndex: pageIndex)
        // 阅读中触达更新时间（节流）
        touchCurrentBookUpdatedAt(throttleSeconds: 30)
```
```525:556:BookReader/Views/ReaderView.swift
            DispatchQueue.main.asyncAfter(deadline: deadline) {
                currentChapter = target
                loadContent(for: target)
                updateAdjacentRefs()
                prefetchAroundCurrent()
                // 重置偏移（无动画），此时右侧/左侧预览已参与过滑动，不再二次滑入
                dragOffset = 0
                // 按钮切章也触达
                touchCurrentBookUpdatedAt(throttleSeconds: 0)
            }
```
```842:879:BookReader/Views/ReaderView.swift
                                // 无动画复位，避免二次滑入闪烁
                                dragOffset = 0
                                // 切章立即触达一次
                                touchCurrentBookUpdatedAt(throttleSeconds: 0)
```
```81:97:BookReader/Views/ReaderView.swift
                        ChapterListView(
                            book: book,
                            onSelect: { ch in
                                currentChapter = ch
                                loadContent(for: ch)
                                // 从目录跳转时立即触达
                                touchCurrentBookUpdatedAt(throttleSeconds: 0)
                                showCatalog = false
                            },
```
```885:896:BookReader/Views/ReaderView.swift
    private func touchCurrentBookUpdatedAt(throttleSeconds: Int) {
        let now = Int(Date().timeIntervalSince1970)
        if throttleSeconds <= 0 || now - lastBookUpdatedAtTouchUnixTime >= throttleSeconds {
            DatabaseManager.shared.touchBookUpdatedAt(bookId: currentChapter.bookid, at: now)
            lastBookUpdatedAtTouchUnixTime = now
        }
    }
```

现在运行应用后，阅读页会自动更新该书的`updatedat`，列表已按该字段倒序显示，常读书会排在前面。

---

