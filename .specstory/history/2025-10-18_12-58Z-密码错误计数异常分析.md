<!-- Generated by SpecStory -->

<!-- cursor Session 64d8ea18-ff33-41be-aa42-1ac66f2f3d66 (2025-10-18 12:58Z) -->

# 密码错误计数异常分析 (2025-10-18 12:58Z)

_**User (2025-10-18 12:56Z)**_

输入了错误密码，第一次左右摆动时，提示1次密码错误；然后第二次左右摆动时（设置了numberOfShakes：4），提示就变成了2次密码输入错误。接着输入错误密码，就会被锁定了

即2次密码错误就锁定了，多判断了一次，是什么原因呢

---

_**Assistant (claude-4.5-sonnet-thinking)**_

<think><details><summary>Thought Process</summary>用户报告了一个密码验证的bug：
1. 第一次输入错误密码，提示"1次密码错误"
2. 第二次输入错误密码，提示"2次密码输入错误"
3. 然后就被锁定了

用户说实际上只输入了2次错误密码就被锁定了，而不是3次。这意味着有重复计数的问题。

我需要查看代码来找出问题。让我先看看BookReaderApp.swift文件，因为这是当前打开的文件。</details></think>

---

我来帮你检查一下密码验证的逻辑问题。让我先查看相关代码。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift

---

<think><details><summary>Thought Process</summary>看代码，我发现了问题所在！

在 `onVerifyPasscode` 函数中（242-261行）：

```swift
private func onVerifyPasscode(_ code: String) {
    if PasscodeManager.shared.verifyPasscode(code) {
        isUnlocked = true
        failedAttempts = 0
        lockUntil = nil
        lockWorkItem?.cancel()
        ensureSecurityOverlayDismissed()
    } else {
        isUnlocked = false
        // 失败计数与锁定策略
        failedAttempts += 1
        failureNonce &+= 1

        if failedAttempts == attemptsToLock {
            startLock(for: firstLockedMinute * 10)  // 1 分钟
        } else if failedAttempts > attemptsToLock {
            startLock(for: secondLockedMinutes * 10)  // 10 分钟
        }
    }
}
```

问题是在密码验证失败时，代码同时增加了 `failedAttempts` 和 `failureNonce`。

再看 `SecurityOverlayView` 中的两个 `onChange`：

1. `onChange(of: failureNonce)` (357-370行) - 这个会在密码错误时触发摇动动画
2. `onChange(of: failedAttempts)` (371-379行) - 这个也会在错误次数增加时触发

但是，最关键的问题是：用户描述的是"第一次摇动时提示1次错误，第二次摇动时提示2次错误"。这意味着在一次错误输入后，`failedAttempts` 被增加了两次！


我需要追踪是否有其他地方在重复增加失败尝试次数。输入处理逻辑可能存在额外的计数机制，导致意外的行为。代码中的 `onChange(of: input)` 部分可能隐藏着额外的触发点。</details></think>

---

_**User (2025-10-18 12:56Z)**_

请继续

---

_**Assistant (claude-4.5-sonnet-thinking)**_

<think><details><summary>Thought Process</summary>用户说"请继续"，我需要回顾之前的分析。让我重新看一下问题：

用户反馈的问题是：
1. 输入错误密码，第一次左右摆动时，提示"1次密码错误"
2. 第二次左右摆动时（设置了numberOfShakes：4），提示变成了"2次密码输入错误"
3. 接着输入错误密码，就会被锁定了
4. 即2次密码错误就锁定了，多判断了一次

我已经读取了代码，现在让我分析问题所在：

看第242-261行的 `onVerifyPasscode` 函数：
```swift
private func onVerifyPasscode(_ code: String) {
    if PasscodeManager.shared.verifyPasscode(code) {
        isUnlocked = true
        failedAttempts = 0
        lockUntil = nil
        lockWorkItem?.cancel()
        ensureSecurityOverlayDismissed()
    } else {
        isUnlocked = false
        // 失败计数与锁定策略
        failedAttempts += 1
        failureNonce &+= 1

        if failedAttempts == attemptsToLock {
            startLock(for: firstLockedMinute * 10)  // 1 分钟
        } else if failedAttempts > attemptsToLock {
            startLock(for: secondLockedMinutes * 10)  // 10 分钟
        }
    }
}
```

注意第24行：`@State private var attemptsToLock: Int = 3`


我发现问题出在锁定逻辑上。当 `failedAttempts` 等于3时会触发第一次锁定，然后大于3时又会触发第二次锁定。这导致实际上两次错误尝试就会被锁定，而不是预期的三次。

系统通过 `failureNonce` 和 `failedAttempts` 的变化处理错误反馈和焦点控制。关键是异步处理输入清空和焦点恢复的机制，确保用户体验流畅。

输入验证逻辑会实时过滤非数字字符，并限制输入长度为6位。当输入达到6位且系统未锁定时，会异步触发验证流程，保证界面响应性。

关键发现是使用 `oldValue` 而非当前 `input` 可能引入验证不准确的风险。用户报告的错误计数问题显示了一个潜在的状态追踪复杂性。

错误尝试计数似乎遵循递增模式：首次错误标记为1次，随后逐步增加，暗示存在系统性的计数机制。

用户描述了一个逐步升级的错误反馈流程，每次输入错误都会触发界面抖动和错误计数提示。

我需要仔细梳理错误计数的精确逻辑，特别关注状态变化和锁定条件的触发点。

目前看来，系统在第三次错误时锁定，但用户感觉提前发生了锁定。

关键在于抖动动画可能引入了额外的判断逻辑，这可能导致错误计数异常。我将追踪代码中的具体实现细节，看看是否存在多计算一次错误的可能性。

代码中使用 `oldValue` 进行过滤可能是问题根源。这种方式可能在某些输入场景下重复触发验证机制，导致错误计数不准确。

需要仔细检查输入变化的处理逻辑，确保错误计数机制精确且唯一。

直接使用当前 `input` 值进行数字过滤，可以避免不必要的重复验证。</details></think>

---

我找到问题了！问题出在密码输入处理逻辑中。

看第 **423-437行** 的 `onChange(of: input)` 处理：

```swift:423:437:BookReader/BookReaderApp.swift
.onChange(of: input) { oldValue, _ in
    let digitsOnly = oldValue.filter { $0.isNumber }
    let normalized = String(digitsOnly.prefix(6))
    if input != normalized { input = normalized }

    // 在非锁定情况下，输入满 6 位先显示最后一个点，再触发校验
    if !isLockedNow && normalized.count == 6 {
        let code = normalized
        DispatchQueue.main.asyncAfter(
            deadline: .now() + 0.05
        ) {
            onVerify(code)
        }
    }
}
```

**问题所在**：

第424行使用了 `oldValue` 来过滤数字：
```swift
let digitsOnly = oldValue.filter { $0.isNumber }
```

但应该使用当前的 `input` 值！这会导致：
1. 当用户输入第6位数字时，`oldValue` 还是5位
2. 然后第427行 `if input != normalized` 会触发，将 `input` 重新赋值
3. 这会再次触发 `onChange`，导致**验证被调用多次**
4. 结果就是一次错误输入，`failedAttempts` 可能增加了2次

**解决方案**：

---

Cancelled

---



---

_**User (2025-10-18 12:56Z)**_

请继续

---

_**Assistant (claude-4.5-sonnet-thinking)**_

<think><details><summary>Thought Process</summary>用户让我继续。我刚才分析了问题，现在需要修复代码。问题是在第424行使用了 `oldValue` 而不是 `input`，这导致验证被调用多次。

我需要修改第424行，将 `oldValue.filter` 改为 `input.filter`。</details></think>

---

好的，让我修复这个问题：

---

Tool use: **search_replace**


<details><summary>Edit file: /Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift</summary>

**Chunk 1**
Lines added: 2, lines removed: 2

```diff
@@ -421,6 +421,6 @@
                      .textContentType(.oneTimeCode)
                      .focused($isFieldFocused)
-                     .onChange(of: input) { oldValue, _ in
-                         let digitsOnly = oldValue.filter { $0.isNumber }
+                     .onChange(of: input) { _, newValue in
+                         let digitsOnly = newValue.filter { $0.isNumber }
                          let normalized = String(digitsOnly.prefix(6))
                          if input != normalized { input = normalized }
```

</details>

---

<think><details><summary>Thought Process</summary>好的，我已经修复了问题。现在让我检查一下是否有其他linter错误。</details></think>

---

完美！问题已修复。让我检查一下是否有任何编译错误：

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 1 file</summary>
      
Lint paths:

- `/Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift`

Lint results


**No lint errors found**
</details>

---

<think><details><summary>Thought Process</summary>很好，没有linter错误。现在让我向用户解释我做了什么修改。</details></think>

---

完美！问题已经解决了。

## 问题原因

在第 **424行** 的代码中，原来使用了 `oldValue` 来过滤数字：
```swift
let digitsOnly = oldValue.filter { $0.isNumber }
```

这会导致以下问题：
1. 当用户输入第6位数字时，`oldValue` 还是5位数字的值
2. 然后第426行的 `if input != normalized` 判断为真，会重新给 `input` 赋值
3. 这会**再次触发** `onChange`，导致 `onVerify` 被调用**两次**
4. 结果就是一次错误输入，`failedAttempts` 增加了2次，所以2次错误密码就达到了3次的锁定阈值

## 解决方案

我将第 **423-424行** 修改为：
```swift
.onChange(of: input) { _, newValue in
    let digitsOnly = newValue.filter { $0.isNumber }
```

现在使用 `newValue`（即当前的新值）来过滤数字，这样就不会触发二次验证了。每次错误输入只会增加1次失败计数，符合预期的"3次错误后锁定"的逻辑。

现在可以测试一下，应该需要完整的3次错误密码输入才会被锁定了！🔐

---

