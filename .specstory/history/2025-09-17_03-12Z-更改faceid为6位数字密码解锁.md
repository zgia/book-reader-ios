<!-- Generated by SpecStory -->

<!-- cursor Session 8de29cb7-5ae0-4996-aa13-56662a9e29e3 (2025-09-17 03:12Z) -->

# 更改FaceID为6位数字密码解锁 (2025-09-17 03:12Z)

_**User (2025-09-17 03:12Z)**_

请@BookReaderApp.swift 请将FaceID验证解锁改成6位数字密码解锁，不再需要FaceID来验证了。可以移除6位数字密码即不要密码解锁，设置了密码后，同样需要一个SecurityOverlay

可以在@AppSettingsView.swift 设置6位数字密码

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Implementing PIN lock**

I need to switch from FaceID to a 6-digit PIN lock for the app. Currently, it uses LocalAuthentication for FaceID or passcode. Now, the plan is to create a custom passcode option in settings, which can be removed. When a password is set, a security overlay should appear to require the passcode. I also need to integrate the existing `securityOverlayEnabled` toggle so it functions correctly depending on whether the password is set or removed.
**Tying overlay to passcode**

I’m thinking we should link the overlay requirement to whether a passcode exists or to the existing toggle. Since the user mentioned needing a SecurityOverlay when a password is set, I’ll make sure it always appears in that case. We'll remove the LAContext usage and show the SecurityOverlayView for PIN entry instead. I also need to modify the AppSettingsView to enable users to set, confirm, change, or remove their 6-digit PIN securely using Keychain. I’ll implement a Keychain helper and create a `PinLockManager` for managing the PIN.
**Implementing security features**

I’m realizing security isn’t just about reading; I need to create a `Utils/KeychainService.swift` and maybe `Utils/PinLockManager.swift`. The KeychainService will handle setting, getting, and deleting entries for our service or accounts. For the PinLockManager, a singleton class feels right, although I prefer value types, so I need to decide on that. The app uses SwiftUI with `@AppStorage`, but we ought to avoid storing the PIN there. Instead, we'll quickly check if a PIN exists using Keychain and present the relevant UI in `@AppSettingsView.swift`. I also need to check the structure of `DefaultsKeys.swift` for adding necessary constants.</details></think>

---

我将先浏览现有代码以确定如何接入新的6位数字密码功能，并规划要新增的工具类与UI改动。接着我会并行查看与设置、默认键和工具相关的文件，便于添加 Keychain 存储及 Defaults 键。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Utils/DefaultsKeys.swift

---

<think><details><summary>Thought Process</summary>**Implementing Passcode Authentication**

I need to switch from FaceID to a 6-digit passcode for the app. The first step is updating BookReaderApp.swift by replacing FaceID authentication with the numerical passcode. The user should be able to set this passcode in AppSettingsView.swift. I’ll need to ensure that we securely store the passcode in the Keychain since we don't have a Keychain helper yet. I also think we should integrate a UserDefaults boolean to indicate whether a passcode is set.
**Clarifying Passcode and Security Overlay Requirements**

The user wants to use a passcode for unlocking the app. They prefer the security overlay to appear when the app is locked or enters the background. They also mentioned the option to remove the passcode entirely. It seems that if the passcode is set, the overlay should always be active, and if not, it should be disabled. Furthermore, the overlay will need to show up when launching the app if a passcode is set, without requiring a separate toggle option.
**Streamlining the Overlay and Passcode Logic**

The existing overlay toggle might be unnecessary, although we could keep it with a default setting. The instructions state to change to a 6-digit passcode, but there's also a suggestion to remove the passcode requirement entirely. It looks like we could simplify things by using whether a passcode is set as the main variable for the overlay. We can maintain the existing securityOverlayEnabled for compatibility but introduce a new key for the passcode state, since passcode data will be in Keychain and not in user defaults.
**Determining Passcode Management Strategy**

I could create a @State variable called passcodeSet, which I would update when the settings change or the view appears. Alternatively, I could use AppStorage for a flag called PasscodeEnabled to track whether the passcode exists, updating it accordingly as users set or remove the passcode. It's okay to store this setting in UserDefaults, even if the passcode itself is stored securely in Keychain. Now, I'll look for any existing Keychain helper.</details></think>

---

我将并行搜索是否已有 Keychain 工具/密码相关实现，以及阅读与读取/保存设置相关的核心文件，确保新增的密码功能可以正确接入。

---

Tool use: **codebase_search**

<details>
                <summary>Searched codebase "Where is Keychain or password securely stored? Any Keychain helper or passcode feature?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `BookReader/BookReaderApp.swift` | L116-169 |
| `BookReader/BookReaderApp.swift` | L30 |
| `CLAUDE.md` | L103 |
| `BookReader/BookReaderApp.swift` | L72-120 |
| `BookReader/BookReaderApp.swift` | L25-77 |
| `BookReader.xcodeproj/project.pbxproj` | L255-302 |
| `BookReader/BookReaderApp.swift` | L206-258 |
| `BookReader.xcodeproj/project.pbxproj` | L300-341 |
| `BookReader/Utils/DefaultsKeys.swift` | L17 |
| `BookReader/BookReaderApp.swift` | L166-213 |
| `BookReader/Data/DatabaseManager.swift` | L28 |
| `BookReader/Reading/ProgressStore.swift` | L57 |
| `BookReader/Views/AppSettingsView.swift` | L44 |
| `BookReader/Views/AppSettingsView.swift` | L184-233 |
| `BookReader/Resources/book.sql` | L107 |

</details>

---

Tool use: **grep**

<details>
<summary>Grep for "Keychain|LAContext|deviceOwnerAuthentication|biometry" in "/Users/zgia/program/projects/zgia/book-reader" • 5 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./BookReader/BookReaderApp.swift` | `let context = LAContext()` | L124 |
| `./BookReader/BookReaderApp.swift` | `let policy: LAPolicy = .deviceOwnerAuthentication` | L128 |
| `./BookReader/BookReaderApp.swift` | `case .biometryNotAvailable: return "生物识别不可用"` | L202 |
| `./BookReader/BookReaderApp.swift` | `case .biometryNotEnrolled: return "未录入生物识别信息"` | L203 |
| `./BookReader/BookReaderApp.swift` | `case .biometryLockout: return "生物识别被锁定，请稍后再试"` | L204 |


</details>

---

Tool use: **codebase_search**

<details>
                <summary>Searched codebase "How are app settings stored and updated? Where are DefaultsKeys used?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `BookReader/Utils/DefaultsKeys.swift` | L17 |
| `BookReader/Reading/ReadingSettings.swift` | L33 |
| `BookReader/Views/AppSettingsView.swift` | L44 |
| `BookReader/BookReaderApp.swift` | L30 |
| `BookReader/Reading/ProgressStore.swift` | L57 |
| `BookReader/Reading/ReadingSettings.swift` | L30-83 |
| `BookReader/Views/ReaderView.swift` | L47 |
| `BookReader/Reading/AppAppearanceSettings.swift` | L39 |
| `BookReader/Views/AppSettingsView.swift` | L184-233 |
| `BookReader/Views/ReaderSettingsView.swift` | L23 |
| `BookReader/BookReaderApp.swift` | L25-77 |
| `CLAUDE.md` | L103 |
| `BookReader/Utils/DebugUtils.swift` | L40 |
| `BookReader/Views/AppSettingsView.swift` | L265-321 |
| `BookReader/Data/Models.swift` | L81 |

</details>

---



---

_**User (2025-09-17 03:12Z)**_

请继续

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Refining security logic**

I'm working on the logic for the security overlay features. If `securityOverlayEnabled` is true and a passcode is set, the app should lock and require the passcode to unlock. But if there's no passcode set, maybe we shouldn't require an unlock—just an overlay for hiding when in the background. The user text hints at not wanting a password unlock, so if there's no passcode, we might skip the overlay.

For storing the passcode securely, I'll implement a `KeychainHelper` to handle hashed passcodes, possibly using salted hashes for better security.
**Planning Keychain integration**

I'm deciding on storing the code directly in Keychain using `kSecClassGenericPassword` for simplicity while also considering a salt. The security guidelines recommend encrypting sensitive data and securely utilizing the Keychain, which seems fine.

I’ll create a `Utils/KeychainService.swift` with functions to set, get, and delete the passcode. I plan to add a boolean in UserDefaults to track passcode status, but also check for its presence in Keychain for better accuracy. 

Additionally, I need to ensure the app knows if a passcode exists, so I'll query this on launch while modifying the `NovelReaderApp` in `BookReaderApp.swift` to manage passcode authentication.
**Implementing passcode features**

I plan to add a `@State` variable called `hasPasscode` and load it when the view appears using `PasscodeManager.shared.hasPasscode()`. 

Next, I’ll replace the `authenticate()` function to present a passcode entry modal overlay. This overlay, `SecurityOverlayView`, needs to be redesigned to include a keypad for passcode entry instead of the current Face ID button. While there's complexity involved, I can implement a simple overlay by modifying it to feature TextFields. 

For security, it might be best to use a custom keypad, but I can also go with `SecureField` and a number pad limit to six digits.
**Addressing overlay and passcode setup**

The `SecurityOverlay` covers the window, which is fine, as the keyboard appears in iOS. I’ll set up a `@State private var passcodeInput: String = ""` in `NovelReaderApp`. Since `SecurityOverlayView` is a pure subview, I’m considering adding properties for binding the passcode input and buttons. Alternatively, I could move passcode handling into the overlay view, but it’s a nested private struct.

I want to create a `PasscodeManager` class in the Utils to handle Keychain operations like setting, removing, validating, and checking for a passcode. 

In `AppSettingsView`, I'll add a new security section with buttons for setting, changing, or removing the passcode, indicating whether a passcode is set. If we implement a simple sheet for entering a passcode twice, I discovered SwiftUI Alert requires iOS 17 for text fields—so I should present it accordingly.
**Implementing passcode settings and overlay**

I need to set up a passcode entry system. It seems easier to present a sheet instead of using an alert with TextFields since that's only supported in iOS 17. I’ll create a `PasscodeSettingsView`, where users can set or change their passcode. If an existing passcode is present, I'll ask for the current one, but I also want to allow direct overrides.

I plan to add `PasscodeEntryOverlay` while sticking with `SecurityOverlayView`, which will show the passcode input and buttons. I'll also remove any use of `LocalAuthentication`. For the flow in `NovelReaderApp`, the overlay will activate based on certain conditions, like having a passcode and its visibility state.

I'll set up notifications for passcode changes and maintain the logic for checking the passcode in Keychain. For organizational purposes, I should create a new file for `PasscodeManager`, while keeping usability in mind when managing Keychain interactions. Finally, I’ll consider the overall project structure and minimize modifications to the Xcode project to streamline the updates.
**Setting up passcode management**

I’ll create the `PasscodeManager.swift` file and carefully modify the `project.pbxproj` file to add it to the target. Since it can be error-prone, I might also consider adding the passcode functionality directly within the existing `DefaultsKeys.swift`. I’ll implement the necessary methods for handling the passcode in Keychain, including setting, validating, and removing it.

In `BookReaderApp.swift`, I’ll remove any unnecessary LocalAuthentication imports, add a notification for passcode changes, and manage the overlay logic based on the presence of a passcode. I need to ensure the overlay requests for a six-digit passcode and incorporates the new `PasscodeSettingsView`, which I'll also add as a nested struct within `AppSettingsView.swift`. Finally, I’ll ensure that UI elements enforce numeric input and validate passcode requirements.
**Managing passcode saving and removal**

When saving a passcode, I’ll first check if there’s an existing one. If so, I’ll validate the old passcode; otherwise, I’ll ignore that step. Next, I’ll ensure that the new passcodes match and are six digits long before calling `PasscodeManager.shared.setPasscode`. After that, I’ll post a `.passcodeChanged` notification and dismiss the view. 

For removing the passcode, I’ll call `PasscodeManager.shared.removePasscode()`, set `hasPasscode` to false, and decide on how to display the status message. Adapting the UI might be simpler than adding new states, so I’ll consider updating `securityView` to manage passcode messages directly. Lastly, I need to update the `pbxproj` to include the new file.</details></think>

---

我将创建密码管理工具、更新解锁逻辑与设置界面，并在需要处修改/新增文件。先读取并修改 Xcode 工程配置以包含新文件。

---

Tool use: **grep**

<details>
<summary>Grep for "Utils" in "/Users/zgia/program/projects/zgia/book-reader/BookReader.xcodeproj/project.pbxproj" • 0 matches</summary>

Output mode: content


_No matches found_

</details>

---

<think><details><summary>Thought Process</summary>**Implementing passcode switch**

I need to switch from FaceID to a 6-digit passcode. First, I should remove or adjust LocalAuthentication usage to validate the passcode with Keychain or AppStorage. When the user sets a password, the app needs to require entering the passcode to unlock using a SecurityOverlay.

In the AppSettingsView, I’ll add a UI for users to set and remove their 6-digit passcode, utilizing a sheet for confirmations. Secure storage using Keychain is crucial, so I'll create a `PasscodeManager` for handling storage safely with SHA-256 hashing using CryptoKit. Keeping dependencies minimal seems smart, given CryptoKit is built into Swift.
**Implementing Keychain access**

I’m planning to use the Security framework wrappers for Keychain access. I’ll consider adding DefaultsKeys for `isPasscodeEnabled`, as the passcode's existence means it is enabled, but I want the UI to reflect that.

There’s also the idea of storing a boolean for toggling SecurityOverlay. When enabled, a passcode will be required if set. The user specifically wants the overlay even when a passcode is set. I think maintaining this toggle will help govern when the overlay appears, but it seems the user’s focus is on ensuring that the overlay is used when the passcode is required. Balancing these options carefully seems important.
**Modifying SecurityOverlayView**

I need to update `SecurityOverlayView` to show a passcode input interface instead of the Face ID button. The plan is to include a PIN pad UI within the overlay, which will still cover the blurred background. I think I can use 6 placeholders for the passcode input, a numeric keypad, and buttons for "删除" and "清空". Since this is an iOS app, I’ll use `SecureField` with a .numberPad keyboardType and a maximum length of 6 digits, along with a "解锁" button. 

This modified overlay will replace the current UI that’s activated when the scene phase is inactive or locked.
**Adjusting authentication flow**

I need to modify the `authenticate()` function to properly handle the passcode. The idea is to check `PasscodeManager.shared.hasPasscode` and show the overlay for the passcode input if it exists. I think I can simplify things by removing the LAContext usage entirely and just manage the `isAuthenticating` state to avoid multiple flows during lock attempts.

Instead, when the overlay appears, I’ll set `isUnlocked` to false. The app will unlock once the user enters the correct code, which will set `isUnlocked` to true. This streamlined approach should work well!
**Implementing passcode overlay**

I need to ensure the overlay allows for passcode entry. Currently, it relies on `onRetry` for authentication, but I’ll replace that content. The first step is to create a `PasscodeManager` using Keychain and CryptoKit.

In `BookReaderApp.swift`, I’ll remove unnecessary imports and the `authenticate()` method. When the overlay is displayed, I plan to set `isUnlocked` to false only if the passcode exists. The overlay should only function when a passcode is set, so I've got to update that toggle behavior accordingly. I'll also ensure necessary error messaging is in place and streamline the overlay view with a numeric input field and manage the submission process effectively. This will help create a smooth user experience when dealing with passcode entry.
**Implementing passcode settings**

I need to set up a system where, upon submission, the app notifies users through a toast message using either `importMessage` or a new state called `passcodeMessage`. After setting the passcode, if the overlay is enabled, it will activate when the app returns to the foreground. To clarify, I plan to show a footnote about the overlay's function.

Also, I’ll create a `SetPasscodeView` with two `SecureField` inputs for the passcode and confirmation, ensuring a 6-digit length and providing feedback. I'll position `PasscodeManager` in a new file to maintain organization, but this requires updating the pbxproj, which can be complex. Let's check that too!</details></think>

---

我将添加一个新的 `Utils/PasscodeManager.swift` 并修改 `BookReaderApp.swift` 与 `AppSettingsView.swift`，因此我会先读取并更新 Xcode 工程文件以包含新文件引用与编译项。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader.xcodeproj/project.pbxproj

---

<think><details><summary>Thought Process</summary>**Implementing passcode UI**

I can adapt the SecurityOverlayView to include a passcode input UI. First, I should store the passcode securely in the Keychain instead of UserDefaults. It’s simpler if I store a hashed version in the Keychain. I’ll create a PasscodeManager utility to handle setting, validating, and removing the passcode using Keychain Services. Since there isn’t a Keychain helper, I’ll make a small wrapper. I also need to modify the Xcode project to add the new file, which should auto-include with Xcode’s new features. I'll also need to implement a passcode overlay UI component.
**Creating passcode input UI**

I need to implement an input for a 6-digit passcode with a keypad. The simpler approach would be to show six dot fields and a numeric keypad laid out in a 3x4 grid of buttons. To maintain a compact design, I can create a `PasscodePadView`. I could either place it directly inside `BookReaderApp.swift` or as a new component under `Views/Components.swift`, which already exists. Let's go ahead and open that file to explore the options!</details></think>

---

我将并行读取与 UI 组件和外观设置相关的文件，定位可复用的组件位置，并检查是否已有键盘或输入组件可复用。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/Components.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Reading/AppAppearanceSettings.swift

---

<think><details><summary>Thought Process</summary>**Implementing passcode security**

I'm thinking about the internal state for the entered digits in the SecurityOverlayView and calling a closure when 6 digits are entered to trigger verification. We need to follow the code style, favoring structs and MVVM. I’ll implement this inside `BookReaderApp.swift`, removing the unnecessary LocalAuthentication import. 

For key storage, we need a Keychain helper in the project, so I might add a new file `Utils/Keychain.swift`. Following the instructions, I’ll keep it simple and use Swift's Security framework for Keychain functions with SHA256 for hashing the passcode. I'll also consider using CryptoKit.
**Designing a passcode input**

I’m considering using a TextField with a number pad for the keypad instead of building something more complex. On the iPad, this will display the system numeric keyboard, but it covers the entire app, which might reveal some underlying details. To keep it polished, I prefer implementing a custom keypad with buttons.

A simple idea is to create a `PasscodeInputView` either embedded in the SecurityOverlayView or as a separate reusable file. I’ll include six circles to represent counts and a grid of buttons from 0-9, plus a delete option. When the input reaches six digits, I’ll call `onSubmit(entered)`, while also incorporating state management for `passcodeExists` by querying PasscodeManager upon appearance and changes. I'll need to import PasscodeManager too.
**Setting up passcode flow**

I’m organizing the flow for the passcode functionality. First, when the overlay appears, I’ll check if a passcode is set. If so, authentication is required. If securityOverlayEnabled is false or the overlay isn't needed, I can allow `isUnlocked` to be true. However, if there's no passcode, unlocking shouldn't happen, so I might just keep that simpler.

I’ll define when the overlay is required: either when the passcode is set or the security overlay is enabled. Additionally, when the app goes into the background, I'll set `isUnlocked` to false if the overlay is required and show the overlay when the app returns if it’s still not unlocked.

The `authenticate()` function will be for passcode verification, where I won’t do anything if verification is already in progress. I’ll manage the passcode input within the overlay and handle errors by providing an `authErrorMessage` for incorrect entries.

Lastly, I’m updating `AppSettingsView.swift` to add a new section under security for passcode management with options for changing, removing, or setting the passcode, accompanied by a UI for entering it twice.
**Creating a passcode input solution**

I'm considering using a custom modal or `TextFieldDialog` for a secure number-only entry. While there’s a `TextFieldDialog` in Components.swift, it only supports a single line, not tailored for a 6-digit confirmation. 

So, I plan to develop a dedicated `SetPasscodeView`. I’ll add state variables for showing the passcode sheet and distinguishing between setting and changing the mode. The `PasscodeSetupView` will need instructions and two rows for 6-digit input — the first passcode and a confirmation — using `SecureField` with a numeric keyboard. 

Also, I’ll need to ensure that the overlay toggle updates automatically when the passcode is set, with careful wording for clarity regarding its function.
**Refining passcode and overlay functionality**

I’ll keep the toggle unchanged, but the overlay will show since a passcode exists. I’ve noticed that the footer states no unlocking when closed, yet it contradicts itself by requiring a passcode. So, I’ll update the footer for clarity.

The new overlay condition will show if the scene isn’t active or if the app isn’t unlocked, with both a passcode and security overlay enabled. The overlay should only trigger when a passcode is set, so removing the passcode disables unlock prompts.

When no passcode is set, I won’t authenticate and will set `isUnlocked` to true instead. I'll avoid blocking the app if the overlay toggle is on without a set passcode, aiming for a simple interface. The `PasscodeManager` will help manage the passcode state, and we’ll update the UI accordingly in `AppSettingsView` to show options for setting, changing, or removing a passcode. 

I’ll also make sure to create a new `PasscodeManager.swift` file and ensure it compiles with the current project features. In `BookReaderApp.swift`, I’ll clean up the code by removing unnecessary imports and adjusting state properties related to the passcode. Overall, the goal is to maintain clarity and prevent contradictions while streamlining the user experience with the security overlay.
**Updating authentication and overlay**

I’m going to repurpose the `authenticate()` function to either do nothing or clear any error messages. I’ll need to set up closures for the overlay related to the passcode. The `onSubmitPasscode` closure will be crucial for verifying the passcode through `PasscodeManager`, and if verification fails, we'll show an error message and reset the overlay.

I’ll modify the `SecurityOverlayView` to replace the FaceID UI with a keypad. It will manage the input and trigger submission when the input reaches six characters. The overlay will also clear input upon an error message change.

Additionally, I’ll create a new `PasscodeManager.swift` file and adjust `AppSettingsView` to include a toggle for passcode settings. I need to ensure the app behaves correctly whether the app is in the background or not, based on the presence of a passcode. 

Finally, I’ll keep updating state variables and make sure everything compiles smoothly as I patch the necessary files.</details></think>

---

我将创建新的密码管理工具并修改 `BookReaderApp.swift` 与 `AppSettingsView.swift`，以用6位数字密码解锁并提供设置/移除密码的界面。随后我会检查并修复可能的语法或风格问题。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/Utils/PasscodeManager.swift</summary>
      

```diff
*** Begin Patch
*** Add File: BookReader/Utils/PasscodeManager.swift
+import Foundation
+import Security
+import CryptoKit
+
+/// 管理应用的6位数字密码，使用 Keychain 安全存储（仅存储哈希）
+struct PasscodeManager {
+    static let shared = PasscodeManager()
+
+    private let service = "net.zgia.BookReader.passcode"
+    private let account = "appPasscode"
+
+    /// 是否已设置密码
+    var isPasscodeSet: Bool {
+        loadHash() != nil
+    }
+
+    /// 设置/更新6位密码
+    func setPasscode(_ passcode: String) throws {
+        guard Self.isValid(passcode) else { throw PasscodeError.invalidFormat }
+        let hash = Self.sha256(passcode)
+        if loadHash() == nil {
+            try saveHash(hash)
+        } else {
+            try updateHash(hash)
+        }
+    }
+
+    /// 校验输入密码是否正确
+    func verifyPasscode(_ passcode: String) -> Bool {
+        guard Self.isValid(passcode), let stored = loadHash() else { return false }
+        return stored == Self.sha256(passcode)
+    }
+
+    /// 移除密码
+    func removePasscode() throws {
+        try deleteHash()
+    }
+
+    // MARK: - Private
+    private func saveHash(_ hash: Data) throws {
+        let query: [String: Any] = [
+            kSecClass as String: kSecClassGenericPassword,
+            kSecAttrService as String: service,
+            kSecAttrAccount as String: account,
+            kSecValueData as String: hash,
+        ]
+        let status = SecItemAdd(query as CFDictionary, nil)
+        if status != errSecSuccess { throw PasscodeError.keychain(status) }
+    }
+
+    private func updateHash(_ hash: Data) throws {
+        let query: [String: Any] = [
+            kSecClass as String: kSecClassGenericPassword,
+            kSecAttrService as String: service,
+            kSecAttrAccount as String: account,
+        ]
+        let attrs: [String: Any] = [kSecValueData as String: hash]
+        let status = SecItemUpdate(query as CFDictionary, attrs as CFDictionary)
+        if status == errSecItemNotFound {
+            try saveHash(hash)
+            return
+        }
+        if status != errSecSuccess { throw PasscodeError.keychain(status) }
+    }
+
+    private func loadHash() -> Data? {
+        let query: [String: Any] = [
+            kSecClass as String: kSecClassGenericPassword,
+            kSecAttrService as String: service,
+            kSecAttrAccount as String: account,
+            kSecReturnData as String: true,
+            kSecMatchLimit as String: kSecMatchLimitOne,
+        ]
+        var item: CFTypeRef?
+        let status = SecItemCopyMatching(query as CFDictionary, &item)
+        if status == errSecSuccess { return item as? Data }
+        return nil
+    }
+
+    private func deleteHash() throws {
+        let query: [String: Any] = [
+            kSecClass as String: kSecClassGenericPassword,
+            kSecAttrService as String: service,
+            kSecAttrAccount as String: account,
+        ]
+        let status = SecItemDelete(query as CFDictionary)
+        if status != errSecSuccess && status != errSecItemNotFound {
+            throw PasscodeError.keychain(status)
+        }
+    }
+
+    private static func sha256(_ text: String) -> Data {
+        let data = Data(text.utf8)
+        let digest = SHA256.hash(data: data)
+        return Data(digest)
+    }
+
+    private static func isValid(_ passcode: String) -> Bool {
+        passcode.count == 6 && passcode.allSatisfy { $0.isNumber }
+    }
+}
+
+enum PasscodeError: Error, LocalizedError {
+    case invalidFormat
+    case keychain(OSStatus)
+
+    var errorDescription: String? {
+        switch self {
+        case .invalidFormat: return "密码必须是6位数字"
+        case .keychain(let status): return "Keychain错误: \(status)"
+        }
+    }
+}
+
*** End Patch
```

---

<think><details><summary>Thought Process</summary>**Implementing passcode switch**

I need to switch from Face ID to a numeric 6-digit passcode in the BookReaderApp.swift. The user mentioned that Face ID is no longer needed. I can also disable passcode unlock while keeping the SecurityOverlay for when it is set. Additionally, I need to update the AppSettingsView to allow setting the 6-digit passcode. 

I've added the PasscodeManager, but I need to ensure the lints are correct and see if I should modify project build settings regarding file syncing. It looks like Xcode is set to automatically manage new files based on this sync.
**Modifying passcode flow**

I need to adjust the BookReaderApp.swift to remove Face ID and implement passcode verification. This involves showing a new overlay for passcode input. Currently, there's a SecurityOverlayView displaying a lock icon and a button for Face ID; I'll replace that with a secure numeric keypad for the passcode. 

I could present a sheet for entering the code, but integrating it into the overlay might be better. For simplicity, I may use a TextField for the numeric keypad. Additionally, I need to ensure there's a way to remove the passcode in settings, even though we won't show an option for that directly in the unlock flow.
**Implementing passcode settings**

First, I need to check if we need @AppStorage for the passcode. Actually, we can just use PasscodeManager.isPasscodeSet to check the keychain instead. But I still need the current state for the settings UI toggle. 

In the settings menu, it makes sense to add fields for setting or removing the passcode, likely in the "隐私与安全" section. I'll include a toggle for "设置6位数字密码" and an "移除密码" button if a passcode is already set. 

I'll also update DefaultsKeys to include a boolean for enabling the overlay. When the overlay is enabled and the app isn't unlocked, I’ll need to authenticate accordingly.
**Enhancing the overlay for passcode entry**

I want to ensure that when the passcode is set, the overlay allows inline entry. Currently, though, the overlay prevents interaction with the underlying view. The SecurityOverlayView has a button that triggers an evaluation for Face ID, so I’ll change the content to include a passcode input and unlock button.

This will require creating a local binding for the passcode input. Since the overlay is currently a stateless view, I can modify it to have an "onSubmit(passcode:)" closure and add a state for input management. I’ll also include a 'requiresPasscode: Bool' property to show the passcode pad only when necessary. If the passcode isn’t set, it will automatically authenticate and hide the overlay. This seems like a solid plan!
**Refining authentication flow**

I need to overhaul the authentication method to check if the passcode is set. If it's not, I can set `isUnlocked = true`. If it is set, the overlay should prompt the user with a message to enter the 6-digit passcode. The overlay will call a validate function to verify the passcode with `PasscodeManager.verifyPasscode`. 

I'll create a new `onVerify(passcode)` callback and update the NovelReaderApp to handle the passcode input with local state. I also want to restrict the input to 6 digits and ensure that the overlay triggers correctly. It would be good to maintain the UI’s functionality while adapting the visual style for dark mode. Additionally, I'll update the AppSettingsView with a dedicated area for setting and removing the passcode, ensuring the user experience remains smooth. Finally, I’ll tidy up the existing functions and remove any unnecessary imports or variables to keep things streamlined.
**Implementing passcode settings**

I need to ensure that indentation remains consistent throughout my files, sticking to 4 spaces. I'll begin by updating the BookReaderApp.swift with the necessary edits, specifically to incorporate a passcode section in AppSettingsView. In this section, I will implement a toggle for the passcode, as well as buttons for setting and removing it.

I'll create a modal sheet for passcode settings, requiring two fields for input. I need to implement relevant states, such as showing the modal and tracking the passcode message. The input should only allow digits up to 6 characters, and I’ll validate before saving. Plus, I want to be cautious with ensuring the security overlay remains active when required without forcing a toggle.

Now, I’ll review the files again to make sure everything's up-to-date before applying the necessary modifications with the apply_patch command!</details></think>

---

我将修改解锁逻辑与安全遮罩 UI，替换为6位数字密码验证，并在设置页加入设置/移除密码的界面。随后我会检查并修复可能的语法问题。

---

The model made no changes to the file.

---



---

我将先读取并比对 `BookReaderApp.swift` 的当前内容，再进行精确编辑，替换为数字密码逻辑并更新遮罩视图。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift

---

<think><details><summary>Thought Process</summary>**Updating securityView functionality**

I’m planning to enhance the securityView. If the passcode is set, I’ll display a message saying "已设置密码" and a button labeled "移除密码". If it’s not set, I’ll show options to create a password instead. For input, I might consider a custom modal with `TextFieldDialog`, but it doesn't support secure input. Instead, I can use a sheet with two `SecureField`s for the new passcode and confirmation, along with appropriate validation. Additionally, I’ll ensure the passcode setting impacts the unlocking overlay functions effectively.
**Editing BookReaderApp.swift**

I’m working on updating BookReaderApp.swift. It's important to maintain a consistent 4-space indentation throughout. First, I need to remove `import LocalAuthentication` from line 1 and keep `import SwiftUI`. I also added PasscodeManager using CryptoKit, so I’ll ensure the project can import CryptoKit without extra packages. I’m implementing changes to SecurityOverlayView by adding an `onVerify` closure and a `@State` input string that uses a SecureField with a number pad, filtering for 6-digit inputs. I’ll also adjust the calls related to verification accordingly.
**Updating security overlay and AppSettingsView**

I’ll ensure the security overlay is dismissed properly. First, I’ll remove the now-unused `errorDescription(for:)` and `LocalAuthentication` import, along with function definitions for `LAError`. I'll create a diff patch with the correct context to target only specific blocks for modification. Next, in AppSettingsView.swift, I plan to update the security view for passcode management by adding several `@State` variables. I’ll implement a sheet with input fields and a Save button, ensuring validation for a 6-digit numeric passcode. When saving, I'll handle errors and manage the display messages accordingly.
**Managing unlock states with overlays**

The overlay relies on the `isUnlocked` state from the App, which is set to true when the overlay is disabled. If the overlay is enabled but there’s no passcode, the authentication will automatically unlock on the next check, so there's no need to trigger it right now. We could send a notification to attempt unlocking, but if the app is locked and the overlay is displayed, no input is needed. After removing the passcode, the overlay should disappear after the next app activation, or the next call to `authenticate()`.
**Implementing overlay changes**

I’m considering sending a `dismissAllModals` notification like what we use for active modals, but it might not be the best solution. Alternatively, I could write to `UserDefaults`, or even toggle `securityOverlayEnabled` to manage the app lock/unlock behavior, though that feels intrusive. The user's requirement is clear: when a passcode is set, an overlay should be shown. My interpretation is that if no passcode is set, the overlay can still appear but will unlock automatically. 

I’ll implement modifications in both files, add new UI texts in settings, and adjust the project settings for file management. Since Xcode auto-manages sources in this project, there’s no need for manual changes. Lastly, I’ll update `BookReaderApp.swift` by removing the `import LocalAuthentication`, replacing the `onRetry` closure, and other necessary adjustments carefully.</details></think>

---

我将先精确修改 `BookReaderApp.swift`，将生物识别验证替换为6位密码逻辑，并更新遮罩视图以输入和验证密码。随后我会更新设置页以添加设置/移除密码的界面。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/BookReaderApp.swift
@@
-import LocalAuthentication
 import SwiftUI
@@
-                    if securityOverlayEnabled
-                        && (scenePhase != .active || !isUnlocked)
-                    {
-                        SecurityOverlayView(
-                            showBlur: true,
-                            isUnlocked: isUnlocked,
-                            message: authErrorMessage,
-                            onRetry: { authenticate() }
-                        )
+                    if securityOverlayEnabled
+                        && (scenePhase != .active || !isUnlocked)
+                    {
+                        SecurityOverlayView(
+                            showBlur: true,
+                            isUnlocked: isUnlocked,
+                            message: authErrorMessage,
+                            onVerify: { code in onVerifyPasscode(code) }
+                        )
                         .ignoresSafeArea()
                         .transition(.opacity)
                         .zIndex(999)
                     }
                 }
             }
@@
-    private func authenticate() {
-        if isAuthenticating { return }
-        isAuthenticating = true
-        authErrorMessage = nil
-        let context = LAContext()
-        context.localizedCancelTitle = "取消"
-        var error: NSError?
-
-        let policy: LAPolicy = .deviceOwnerAuthentication
-        if context.canEvaluatePolicy(policy, error: &error) {
-            let reason = "验证以解锁应用"
-            context.evaluatePolicy(policy, localizedReason: reason) {
-                success,
-                evalError in
-                DispatchQueue.main.async {
-                    if success {
-                        isUnlocked = true
-                        authErrorMessage = nil
-                        isAuthenticating = false
-                        // 确保界面状态正确，防止 SecurityOverlayView 卡住
-                        self.ensureSecurityOverlayDismissed()
-                    } else {
-                        isUnlocked = false
-                        isAuthenticating = false
-                        if let laError = evalError as? LAError {
-                            authErrorMessage = errorDescription(for: laError)
-                        } else if let evalError = evalError {
-                            authErrorMessage = evalError.localizedDescription
-                        } else {
-                            authErrorMessage = "验证失败"
-                        }
-                    }
-                }
-            }
-        } else {
-            // 无法评估策略（设备无生物识别/未设置密码等）
-            DispatchQueue.main.async {
-                isUnlocked = false
-                isAuthenticating = false
-                authErrorMessage =
-                    (error as NSError?)?.localizedDescription
-                    ?? "此设备不支持或未启用生物识别/密码"
-            }
-        }
-    }
+    private func authenticate() {
+        if isAuthenticating { return }
+        isAuthenticating = true
+        authErrorMessage = nil
+        // 若未设置密码，直接解锁；否则显示提示，等待用户输入
+        if PasscodeManager.shared.isPasscodeSet {
+            isUnlocked = false
+            isAuthenticating = false
+            authErrorMessage = "请输入6位数字密码"
+        } else {
+            isUnlocked = true
+            isAuthenticating = false
+            authErrorMessage = nil
+            self.ensureSecurityOverlayDismissed()
+        }
+    }
@@
-    private func errorDescription(for laError: LAError) -> String {
-        switch laError.code {
-        case .authenticationFailed: return "身份验证失败"
-        case .userCancel: return "您已取消"
-        case .userFallback: return "请使用密码"
-        case .biometryNotAvailable: return "生物识别不可用"
-        case .biometryNotEnrolled: return "未录入生物识别信息"
-        case .biometryLockout: return "生物识别被锁定，请稍后再试"
-        case .appCancel: return "应用已取消验证"
-        case .systemCancel: return "系统已取消验证"
-        default: return "验证未完成"
-        }
-    }
+    // 校验输入的密码
+    private func onVerifyPasscode(_ code: String) {
+        if PasscodeManager.shared.verifyPasscode(code) {
+            isUnlocked = true
+            authErrorMessage = nil
+            ensureSecurityOverlayDismissed()
+        } else {
+            isUnlocked = false
+            authErrorMessage = "密码错误，请重试"
+        }
+    }
 }
@@
-private struct SecurityOverlayView: View {
+private struct SecurityOverlayView: View {
     var showBlur: Bool
     var isUnlocked: Bool
     var message: String?
-    var onRetry: () -> Void
+    var onVerify: (String) -> Void
+
+    @State private var input: String = ""
@@
-                    if let message = message, !message.isEmpty {
+                    if let message = message, !message.isEmpty {
                         Text(message)
                             .foregroundColor(.black.opacity(0.6))
                             .font(.subheadline)
                             .multilineTextAlignment(.center)
                             .padding(.horizontal)
                     }
-                    Button(action: { onRetry() }) {
-                        HStack {
-                            Image(systemName: "faceid")
-                            Text("使用Face ID解锁")
-                        }
-                        .padding(.horizontal, 16)
-                        .padding(.vertical, 10)
-                        .background(Color.white)
-                        .foregroundColor(.black)
-                        .cornerRadius(10)
-                    }
-                    .padding(.top, 8)
+                    VStack(spacing: 10) {
+                        SecureField("输入6位数字密码", text: $input)
+                            .keyboardType(.numberPad)
+                            .textContentType(.oneTimeCode)
+                            .multilineTextAlignment(.center)
+                            .onChange(of: input) { newValue, _ in
+                                let filtered = newValue.filter { $0.isNumber }
+                                input = String(filtered.prefix(6))
+                            }
+                            .padding(.horizontal)
+                            .padding(.vertical, 10)
+                            .background(Color.white)
+                            .cornerRadius(10)
+                        Button(action: { onVerify(input) }) {
+                            HStack {
+                                Image(systemName: "key.fill")
+                                Text("解锁")
+                            }
+                            .padding(.horizontal, 16)
+                            .padding(.vertical, 10)
+                            .background(Color.white)
+                            .foregroundColor(.black)
+                            .cornerRadius(10)
+                        }
+                        .disabled(input.count != 6)
+                        .padding(.top, 4)
+                        Button(action: { input = "" }) {
+                            HStack {
+                                Image(systemName: "xmark.circle")
+                                Text("清空输入")
+                            }
+                            .padding(.horizontal, 16)
+                            .padding(.vertical, 10)
+                            .background(Color.white)
+                            .foregroundColor(.black)
+                            .cornerRadius(10)
+                        }
+                    }
+                    .padding(.top, 8)
                 }
                 .padding(24)
             }
         }
     }
 }
*** End Patch
```

---



---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/Views/AppSettingsView.swift
@@
     @State private var showingFormatHelp: Bool = false
+    @State private var showingSetPasscode: Bool = false
+    @State private var showingRemovePasscodeConfirm: Bool = false
+    @State private var passcodeInput: String = ""
+    @State private var passcodeConfirmInput: String = ""
+    @State private var passcodeTip: String?
@@
     var body: some View {
         NavigationStack {
             Form {
                 // 外观
                 appAppearanceView()
 
                 // 隐私与安全
-                securityView()
+                securityView()
 
                 // 导入小说
                 bookImporterView()
 
                 // 新的“数据库维护”分区
                 databaseMaintainerView()
             }
@@
     private func securityView() -> some View {
         Section(
             header: Text("隐私与安全"),
             footer: Text("关闭后，应用启动或回到前台将不再要求解锁，也不会显示安全遮罩。").font(
                 .footnote
             ).foregroundColor(.secondary)
         ) {
             Toggle("启用安全遮罩（启动/前台需解锁）", isOn: $securityOverlayEnabled)
+
+            if PasscodeManager.shared.isPasscodeSet {
+                HStack {
+                    Image(systemName: "key.fill").foregroundColor(.green)
+                    Text("已设置6位数字密码")
+                    Spacer()
+                    Button("移除密码", role: .destructive) {
+                        showingRemovePasscodeConfirm = true
+                    }
+                    .font(.footnote)
+                }
+            } else {
+                HStack {
+                    Image(systemName: "key.slash.fill").foregroundColor(.secondary)
+                    Text("未设置密码")
+                    Spacer()
+                    Button("设置密码") { showingSetPasscode = true }
+                        .font(.footnote)
+                }
+            }
         }
+        .alert("确认移除密码？", isPresented: $showingRemovePasscodeConfirm) {
+            Button("取消", role: .cancel) {}
+            Button("移除", role: .destructive) {
+                do {
+                    try PasscodeManager.shared.removePasscode()
+                    passcodeTip = "已移除密码"
+                } catch {
+                    passcodeTip = "移除失败：\(error.localizedDescription)"
+                }
+            }
+        } message: {
+            Text("移除后将不再要求解锁。")
+        }
+        .sheet(isPresented: $showingSetPasscode) {
+            NavigationStack {
+                Form {
+                    Section(footer: Text(passcodeTip ?? "密码需为6位数字").font(.footnote).foregroundColor(.secondary)) {
+                        SecureField("输入新密码", text: $passcodeInput)
+                            .keyboardType(.numberPad)
+                            .onChange(of: passcodeInput) { newValue, _ in
+                                passcodeInput = String(newValue.filter { $0.isNumber }.prefix(6))
+                            }
+                        SecureField("再次输入", text: $passcodeConfirmInput)
+                            .keyboardType(.numberPad)
+                            .onChange(of: passcodeConfirmInput) { newValue, _ in
+                                passcodeConfirmInput = String(newValue.filter { $0.isNumber }.prefix(6))
+                            }
+                    }
+                }
+                .navigationTitle("设置密码")
+                .toolbar {
+                    ToolbarItem(placement: .topBarLeading) {
+                        Button("取消") { showingSetPasscode = false }
+                    }
+                    ToolbarItem(placement: .topBarTrailing) {
+                        Button("保存") {
+                            guard passcodeInput.count == 6, passcodeInput == passcodeConfirmInput else {
+                                passcodeTip = "两次输入不一致或非6位"
+                                return
+                            }
+                            do {
+                                try PasscodeManager.shared.setPasscode(passcodeInput)
+                                passcodeTip = "已设置密码"
+                                showingSetPasscode = false
+                                // 若开启安全遮罩，则立即上锁，下一次进入需输入
+                                if securityOverlayEnabled {
+                                    NotificationCenter.default.post(name: .dismissAllModals, object: nil)
+                                }
+                            } catch {
+                                passcodeTip = "保存失败：\(error.localizedDescription)"
+                            }
+                        }
+                        .disabled(passcodeInput.count != 6 || passcodeConfirmInput.count != 6)
+                    }
+                }
+            }
+            .presentationDetents([.medium])
+        }
     }
*** End Patch
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 3 files</summary>
      
Lint paths:

- `/Users/zgia/program/projects/zgia/book-reader/BookReader/Utils/PasscodeManager.swift`
- `/Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift`
- `/Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift`

Lint results


**No lint errors found**
</details>

---

- 我已新增 `Utils/PasscodeManager.swift`，用 Keychain 安全存储6位数字密码（仅存哈希，CryptoKit SHA256），支持设置、校验、移除。
- 我已重构 `BookReaderApp.swift`：移除生物识别依赖与调用，`authenticate()` 逻辑改为：若未设置密码则直接解锁；若已设置则显示遮罩并提示输入密码；遮罩视图 `SecurityOverlayView` 改为包含 `SecureField` 输入6位数字和“解锁/清空输入”按钮，通过回调校验密码。
- 我已在 `AppSettingsView.swift` 的“隐私与安全”里新增设置/移除6位密码的UI：未设置时显示“设置密码”入口，已设置时显示“移除密码”按钮；设置密码时弹出表单，校验两次输入一致且为6位数字。

接下来你可以运行并在设置页设置6位密码。启用“安全遮罩”后，应用启动或回前台会显示密码输入遮罩，正确输入即解锁。

---

_**User (2025-09-17 03:12Z)**_

有个bug：如果取消了密码，但是仍然启用安全遮罩，那么切换App时，就需要输入密码了。其次，取消密码时，未让输入密码确认。应该改成：
1. 取消密码时，应该输入密码确认
2. 移除“启用安全遮罩”的设置项。如果有密码，则有安全遮罩，没有密码，则无需安全遮罩。即让有无密码来替代“启用安全遮罩”的设置项

---

_**Assistant (gpt-5)**_



---

我将修复安全遮罩与密码移除的逻辑：改为以“是否设置密码”决定遮罩显示，移除设置里的“启用安全遮罩”开关；并在移除密码时添加输入当前密码确认。接下来我会修改 `BookReaderApp.swift` 与 `AppSettingsView.swift`。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/BookReaderApp.swift
@@
-extension Notification.Name {
-    static let dismissAllModals = Notification.Name("dismissAllModals")
-}
+extension Notification.Name {
+    static let dismissAllModals = Notification.Name("dismissAllModals")
+    static let passcodeDidChange = Notification.Name("passcodeDidChange")
+}
@@
-    @Environment(\.scenePhase) private var scenePhase
-    @AppStorage(DefaultsKeys.securityOverlayEnabled) private
-        var securityOverlayEnabled: Bool = true
+    @Environment(\.scenePhase) private var scenePhase
@@
-                    if securityOverlayEnabled
-                        && (scenePhase != .active || !isUnlocked)
+                    if PasscodeManager.shared.isPasscodeSet
+                        && (scenePhase != .active || !isUnlocked)
                     {
                         SecurityOverlayView(
                             showBlur: true,
                             isUnlocked: isUnlocked,
                             message: authErrorMessage,
                             onVerify: { code in onVerifyPasscode(code) }
                         )
@@
-                    if securityOverlayEnabled {
-                        authenticate()
-                    } else {
-                        isUnlocked = true
-                    }
+                    if PasscodeManager.shared.isPasscodeSet {
+                        authenticate()
+                    } else {
+                        isUnlocked = true
+                    }
                 }
             }
             .onChange(of: scenePhase) { newPhase, oldPhase in
                 switch newPhase {
                 case .active:
                     // 回到前台时如果未解锁则再次验证（防抖）
-                    if securityOverlayEnabled && !isUnlocked
+                    if PasscodeManager.shared.isPasscodeSet && !isUnlocked
                         && !isAuthenticating
                     {
                         // 延迟一点验证，确保模态视图已经完全消失
                         DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
-                            if securityOverlayEnabled && !self.isUnlocked
+                            if PasscodeManager.shared.isPasscodeSet && !self.isUnlocked
                                 && !self.isAuthenticating
                             {
                                 self.authenticate()
                             }
                         }
                     }
                 case .background:
                     // 进入后台时立即上锁
-                    if securityOverlayEnabled {
+                    if PasscodeManager.shared.isPasscodeSet {
                         isUnlocked = false
                     }
                     // 取消所有活动的模态视图
                     dismissAllModals()
                 default:
                     break
                 }
             }
-            .onChange(of: securityOverlayEnabled) { newValue, oldValue in
-                if newValue {
-                    // 开启安全遮罩后强制上锁并触发验证
-                    isUnlocked = false
-                    if !isAuthenticating {
-                        authenticate()
-                    }
-                } else {
-                    // 关闭安全遮罩后认为已解锁
-                    isUnlocked = true
-                    authErrorMessage = nil
-                }
-            }
+            .onReceive(NotificationCenter.default.publisher(for: .passcodeDidChange)) { _ in
+                // 密码变更后立即刷新状态：
+                // 若设置了密码，不立刻上锁；若移除了密码，直接解锁
+                if PasscodeManager.shared.isPasscodeSet {
+                    isUnlocked = true
+                    authErrorMessage = nil
+                } else {
+                    isUnlocked = true
+                    authErrorMessage = nil
+                }
+            }
         }
     }
*** End Patch
```

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/Views/AppSettingsView.swift
@@
-    @AppStorage(DefaultsKeys.securityOverlayEnabled) private
-        var securityOverlayEnabled: Bool = true
+    // 由是否设置密码决定是否启用安全遮罩
@@
-                // 隐私与安全
-                securityView()
+                // 隐私与安全
+                securityView()
@@
-    private func securityView() -> some View {
-        Section(
-            header: Text("隐私与安全"),
-            footer: Text("关闭后，应用启动或回到前台将不再要求解锁，也不会显示安全遮罩。").font(
-                .footnote
-            ).foregroundColor(.secondary)
-        ) {
-            Toggle("启用安全遮罩（启动/前台需解锁）", isOn: $securityOverlayEnabled)
-
-            if PasscodeManager.shared.isPasscodeSet {
-                HStack {
-                    Image(systemName: "key.fill").foregroundColor(.green)
-                    Text("已设置6位数字密码")
-                    Spacer()
-                    Button("移除密码", role: .destructive) {
-                        showingRemovePasscodeConfirm = true
-                    }
-                    .font(.footnote)
-                }
-            } else {
-                HStack {
-                    Image(systemName: "key.slash.fill").foregroundColor(.secondary)
-                    Text("未设置密码")
-                    Spacer()
-                    Button("设置密码") { showingSetPasscode = true }
-                        .font(.footnote)
-                }
-            }
-        }
+    private func securityView() -> some View {
+        Section(
+            header: Text("隐私与安全"),
+            footer: Text("已设置密码时，应用启动或回到前台将显示安全遮罩并需要输入密码解锁。移除密码则不再需要解锁。").font(
+                .footnote
+            ).foregroundColor(.secondary)
+        ) {
+            if PasscodeManager.shared.isPasscodeSet {
+                HStack {
+                    Image(systemName: "key.fill").foregroundColor(.green)
+                    Text("已设置6位数字密码")
+                    Spacer()
+                    Button("移除密码", role: .destructive) {
+                        showingRemovePasscodeConfirm = true
+                    }
+                    .font(.footnote)
+                }
+            } else {
+                HStack {
+                    Image(systemName: "key.slash.fill").foregroundColor(.secondary)
+                    Text("未设置密码")
+                    Spacer()
+                    Button("设置密码") { showingSetPasscode = true }
+                        .font(.footnote)
+                }
+            }
+        }
@@
-        .alert("确认移除密码？", isPresented: $showingRemovePasscodeConfirm) {
-            Button("取消", role: .cancel) {}
-            Button("移除", role: .destructive) {
-                do {
-                    try PasscodeManager.shared.removePasscode()
-                    passcodeTip = "已移除密码"
-                } catch {
-                    passcodeTip = "移除失败：\(error.localizedDescription)"
-                }
-            }
-        } message: {
-            Text("移除后将不再要求解锁。")
-        }
+        .sheet(isPresented: $showingRemovePasscodeConfirm) {
+            NavigationStack {
+                Form {
+                    Section(footer: Text(passcodeTip ?? "请输入当前6位密码以确认移除").font(.footnote).foregroundColor(.secondary)) {
+                        SecureField("当前密码", text: $passcodeInput)
+                            .keyboardType(.numberPad)
+                            .onChange(of: passcodeInput) { newValue, _ in
+                                passcodeInput = String(newValue.filter { $0.isNumber }.prefix(6))
+                            }
+                    }
+                }
+                .navigationTitle("移除密码")
+                .toolbar {
+                    ToolbarItem(placement: .topBarLeading) {
+                        Button("取消") { showingRemovePasscodeConfirm = false }
+                    }
+                    ToolbarItem(placement: .topBarTrailing) {
+                        Button("移除", role: .destructive) {
+                            if PasscodeManager.shared.verifyPasscode(passcodeInput) {
+                                do {
+                                    try PasscodeManager.shared.removePasscode()
+                                    passcodeTip = "已移除密码"
+                                    showingRemovePasscodeConfirm = false
+                                    NotificationCenter.default.post(name: .passcodeDidChange, object: nil)
+                                } catch {
+                                    passcodeTip = "移除失败：\(error.localizedDescription)"
+                                }
+                            } else {
+                                passcodeTip = "密码错误"
+                            }
+                        }
+                        .disabled(passcodeInput.count != 6)
+                    }
+                }
+            }
+            .presentationDetents([.medium])
+        }
@@
-                        Button("保存") {
+                        Button("保存") {
                             guard passcodeInput.count == 6, passcodeInput == passcodeConfirmInput else {
                                 passcodeTip = "两次输入不一致或非6位"
                                 return
                             }
                             do {
                                 try PasscodeManager.shared.setPasscode(passcodeInput)
                                 passcodeTip = "已设置密码"
                                 showingSetPasscode = false
-                                // 若开启安全遮罩，则立即上锁，下一次进入需输入
-                                if securityOverlayEnabled {
-                                    NotificationCenter.default.post(name: .dismissAllModals, object: nil)
-                                }
+                                NotificationCenter.default.post(name: .passcodeDidChange, object: nil)
                             } catch {
                                 passcodeTip = "保存失败：\(error.localizedDescription)"
                             }
                         }
                         .disabled(passcodeInput.count != 6 || passcodeConfirmInput.count != 6)
                     }
                 }
             }
             .presentationDetents([.medium])
         }
     }
*** End Patch
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 2 files</summary>
      
Lint paths:

- `/Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift`
- `/Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift`

Lint results


**No lint errors found**
</details>

---

- 我已移除“启用安全遮罩”的设置项，改为由是否设置密码来决定是否显示遮罩：仅当设置了6位密码且应用不在活跃状态或未解锁时才显示遮罩。
- 我已修复取消密码的流程：取消时需要输入当前6位密码确认，验证通过后移除密码并广播 `passcodeDidChange` 以刷新应用状态。
- 我已更新 `BookReaderApp.swift` 的判断和生命周期处理：全部改为依赖 `PasscodeManager.shared.isPasscodeSet` 控制上锁/解锁，并在密码变更时同步状态。

---

_**User (2025-09-17 03:12Z)**_

非常好。不过产生了个新BUG：设置密码后，密码就会缓存到输入框内。或者取消密码，再设置密码时，第一个密码输入框已经有密码了。应该清空密码的。

其次，在安全遮罩视图，是否可以让输入框自动获取焦点，弹出数字键盘？设置密码时，第一个输入框也自动获取焦点；取消密码时，确认密码的输入框，也自动获取焦点

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Implementing security features**

I’m focusing on fixing the caching of the passcode in input fields. After setting the password, the fields should clear, and they need to reset every time the overlay is presented, when unlock succeeds, or if the passcode changes.

Next, I'll ensure the numeric keypad auto-focuses in SwiftUI on iOS 15+. I'll utilize @FocusState to manage this, but it seems sheets may require additional settings to show the keyboard automatically. I’ll pay attention to the iPad’s keypad behavior too.
**Modifying SecureField focus**

I need to use .focused($fieldFocused) on my SecureField and also utilize .task for setting focus and .onAppear. 

I’ll modify the BookReaderApp’s SecurityOverlayView by adding @FocusState private var focused: Bool. Then, I will set .focused($focused) on SecureField, initializing it in .onAppear { focused = true } and using .onChange to clear input when locking or unlocking. This involves addressing an "input caching" bug where the input lingers in the @State variable across re-appearances, even when the overlay gets re-rendered. It’s crucial to ensure the input starts empty whenever the overlay reappears.
**Addressing input caching issues**

The user pointed out that the input fields are caching during password setting flows in the AppSettingsView sheets. Both the set password and remove password sheets share the same @State variables for passcodeInput and passcodeConfirmInput, which leads to them persisting. 

I need to reset those variables to empty strings when toggling sheet booleans to true, and after completing actions as well. Additionally, in SecurityOverlayView, I can reset input when the message changes or onAppear. 

For both sheets, I’ll use @FocusState to auto-focus the initial secure field on appearance. For the keyboard, we’ve set the keyboard type to .numberPad, but sometimes SecureField doesn’t auto-focus, so I’ll explore using .task for that.
**Implementing focus and input clearing**

I'm considering using onAppear for focus change, implementing both .onAppear { focused = true } and .onChange(of: isUnlocked) to set focus when it locks.

I’ll also clear input fields on success by setting input to an empty string. For passcode changes, if the overlay hides, that's okay.

When opening the set password or remove password sheets, I’ll ensure that passcodeInput and passcodeConfirmInput are reset to empty strings by modifying the AppSettingsView. Adding @FocusState for the fields will help, focusing mainly on the first field as needed. Lastly, I’ll link everything within the sheet content.
**Implementing focus and input clearing in sheets**

I’m going to set focus on the first field by using focused($setPasscodeFocused1) in .onAppear. For the SecurityOverlayView, I’ll add @FocusState var isFieldFocused and set it to ensure the keyboard displays when needed, using DispatchQueue to delay slightly.

When the user taps "Clear input," I'll reset focus back to true. I need to ensure that after setting or removing a password, states clear even if the sheet closes. I’ll maintain a 4-space indentation to match the AppSettingsView style.

Next, I'll modify buttons to reset inputs before presenting sheets. In the set password sheet, I’ll define @FocusState variables at the struct level. Then, I’ll ensure the focus works correctly for both sheets, implementing these patches in the relevant files.</details></think>

---

我会先在遮罩视图与设置页中加入自动聚焦与输入清空的逻辑，并在打开设置/移除密码的弹窗时重置输入状态，确保不会缓存旧密码。随后我会更新遮罩视图的 SecureField 使用 @FocusState 自动弹出数字键盘。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/BookReaderApp.swift
@@
 private struct SecurityOverlayView: View {
     var showBlur: Bool
     var isUnlocked: Bool
     var message: String?
     var onVerify: (String) -> Void
 
     @State private var input: String = ""
+    @FocusState private var isFieldFocused: Bool
 
     var body: some View {
         ZStack {
             if showBlur {
                 Rectangle()
                     .fill(.regularMaterial)
             }
@@
                     VStack(spacing: 10) {
                         SecureField("输入6位数字密码", text: $input)
                             .keyboardType(.numberPad)
                             .textContentType(.oneTimeCode)
                             .multilineTextAlignment(.center)
+                            .focused($isFieldFocused)
                             .onChange(of: input) { newValue, _ in
                                 let filtered = newValue.filter { $0.isNumber }
                                 input = String(filtered.prefix(6))
                             }
                             .padding(.horizontal)
                             .padding(.vertical, 10)
                             .background(Color.white)
                             .cornerRadius(10)
                         Button(action: { onVerify(input) }) {
@@
                         .disabled(input.count != 6)
                         .padding(.top, 4)
                         Button(action: { input = "" }) {
                             HStack {
                                 Image(systemName: "xmark.circle")
                                 Text("清空输入")
                             }
                             .padding(.horizontal, 16)
                             .padding(.vertical, 10)
                             .background(Color.white)
                             .foregroundColor(.black)
                             .cornerRadius(10)
                         }
                     }
                     .padding(.top, 8)
                 }
                 .padding(24)
             }
         }
+        .onAppear {
+            input = ""
+            DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
+                isFieldFocused = true
+            }
+        }
+        .onChange(of: isUnlocked) { newValue, _ in
+            if !newValue {
+                input = ""
+                DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
+                    isFieldFocused = true
+                }
+            }
+        }
     }
 }
*** End Patch
```

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Fixing app settings**

I need to address the patch for the AppSettingsView with precision. First, I’ll read the file to understand how to apply the correct patches properly. It’s essential to ensure that everything is accurate so that the settings function as intended. I want to avoid any mistakes that might create issues later. So, let’s get started and make sure we get this right.</details></think>

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift

---

<think><details><summary>Thought Process</summary>**Implementing feature updates**

I need to implement two features based on user bug reports. First, for clearing password inputs in SecurityOverlay, I've already taken care of resetting the input fields when the component appears or when the unlock state changes. 

Next, in AppSettingsView, the passcode sheet should reset fields when it's opened again. I realize we need to add @FocusState properties, focused modifiers to SecureFields, and .onAppear resets inside the sheet to ensure everything works smoothly. These adjustments should address the caching bug effectively.
**Implementing function adjustments**

I can clear values when toggling showings to true, but I can't run code at that exact moment in SwiftUI. Instead, I'll need to use `.onChange(of: showingSetPasscode)`. The `.onAppear` function inside the sheet should work well for my needs.

I also need to address an auto-focus issue with the Security overlay keypad. I’ll ensure to add `FocusState` and use `.focused` with numberPad settings. Additionally, I need to modify `AppSettingsView` to include `FocusState` properties, `.onAppear` for each sheet, and ensure that the `passcodeTip` resets as expected. I’ll also handle clearing values upon sheet dismissal using `onDisappear`.
**Updating code logic**

I need to make some updates to the code now. In the BookReaderApp, we changed the logic to not use `AppStorage securityOverlayEnabled`, and I’ve already removed the `LocalAuthentication` import. We've also added the `passcodeDidChange` notification.

Now for the specific changes: I’ll add `@FocusState` for the passcode input fields. In the remove password sheet, I'll include `FocusState`, the `.focused` modifier, and an `.onAppear` to reset and focus.

I also want to clear the `passcodeInput` variables when saving or removing. Finally, clearing values when tapping the "设置密码" button means I can set the inputs to empty and show the passcode setup screen.
**Enhancing button functionality**

I see that we currently have a button that shows the passcode setup screen, but I can enhance this by clearing the input fields right before toggling the visibility. The same goes for the removal sheet. 

I'll modify the button for setting the passcode to clear the `passcodeInput`, `passcodeConfirmInput`, and `passcodeTip` earlier on. Similarly, the button for removing the password will also clear the necessary inputs before showing the confirmation. I also need to add `FocusStates` and `.focused` as well. Let’s make sure to keep the indentation consistent and apply these changes in `AppSettingsView.swift`.</details></think>

---

我将更新设置页的输入框：在打开设置/移除密码弹窗时清空输入并自动聚焦对应输入框；在安全遮罩视图已完成自动聚焦和清空。现在开始编辑设置页文件。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/Views/AppSettingsView.swift
@@
     @State private var passcodeConfirmInput: String = ""
     @State private var passcodeTip: String?
+    @FocusState private var setPasscodeFieldFocused: Bool
+    @FocusState private var confirmPasscodeFieldFocused: Bool
+    @FocusState private var removePasscodeFieldFocused: Bool
@@
-                    Button("移除密码", role: .destructive) {
-                        showingRemovePasscodeConfirm = true
-                    }
+                    Button("移除密码", role: .destructive) {
+                        passcodeInput = ""
+                        passcodeTip = nil
+                        showingRemovePasscodeConfirm = true
+                    }
                     .font(.footnote)
                 }
             } else {
                 HStack {
                     Image(systemName: "key.slash.fill").foregroundColor(.secondary)
                     Text("未设置密码")
                     Spacer()
-                    Button("设置密码") { showingSetPasscode = true }
+                    Button("设置密码") {
+                        passcodeInput = ""
+                        passcodeConfirmInput = ""
+                        passcodeTip = nil
+                        showingSetPasscode = true
+                    }
                         .font(.footnote)
                 }
             }
         }
         .sheet(isPresented: $showingRemovePasscodeConfirm) {
             NavigationStack {
                 Form {
                     Section(footer: Text(passcodeTip ?? "请输入当前6位密码以确认移除").font(.footnote).foregroundColor(.secondary)) {
-                        SecureField("当前密码", text: $passcodeInput)
+                        SecureField("当前密码", text: $passcodeInput)
                             .keyboardType(.numberPad)
                             .onChange(of: passcodeInput) { newValue, _ in
                                 passcodeInput = String(newValue.filter { $0.isNumber }.prefix(6))
                             }
+                            .focused($removePasscodeFieldFocused)
                     }
                 }
                 .navigationTitle("移除密码")
                 .toolbar {
                     ToolbarItem(placement: .topBarLeading) {
                         Button("取消") { showingRemovePasscodeConfirm = false }
                     }
                     ToolbarItem(placement: .topBarTrailing) {
                         Button("移除", role: .destructive) {
                             if PasscodeManager.shared.verifyPasscode(passcodeInput) {
                                 do {
                                     try PasscodeManager.shared.removePasscode()
                                     passcodeTip = "已移除密码"
                                     showingRemovePasscodeConfirm = false
                                     NotificationCenter.default.post(name: .passcodeDidChange, object: nil)
                                 } catch {
                                     passcodeTip = "移除失败：\(error.localizedDescription)"
                                 }
                             } else {
                                 passcodeTip = "密码错误"
                             }
                         }
                         .disabled(passcodeInput.count != 6)
                     }
                 }
+                .onAppear {
+                    // 打开移除密码确认页面时重置并自动聚焦
+                    passcodeInput = ""
+                    passcodeTip = nil
+                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
+                        removePasscodeFieldFocused = true
+                    }
+                }
+                .onDisappear {
+                    passcodeInput = ""
+                    passcodeTip = nil
+                }
             }
             .presentationDetents([.medium])
         }
         .sheet(isPresented: $showingSetPasscode) {
             NavigationStack {
                 Form {
                     Section(footer: Text(passcodeTip ?? "密码需为6位数字").font(.footnote).foregroundColor(.secondary)) {
-                        SecureField("输入新密码", text: $passcodeInput)
+                        SecureField("输入新密码", text: $passcodeInput)
                             .keyboardType(.numberPad)
                             .onChange(of: passcodeInput) { newValue, _ in
                                 passcodeInput = String(newValue.filter { $0.isNumber }.prefix(6))
                             }
-                        SecureField("再次输入", text: $passcodeConfirmInput)
+                            .focused($setPasscodeFieldFocused)
+                        SecureField("再次输入", text: $passcodeConfirmInput)
                             .keyboardType(.numberPad)
                             .onChange(of: passcodeConfirmInput) { newValue, _ in
                                 passcodeConfirmInput = String(newValue.filter { $0.isNumber }.prefix(6))
                             }
+                            .focused($confirmPasscodeFieldFocused)
                     }
                 }
                 .navigationTitle("设置密码")
                 .toolbar {
                     ToolbarItem(placement: .topBarLeading) {
                         Button("取消") { showingSetPasscode = false }
                     }
                     ToolbarItem(placement: .topBarTrailing) {
                         Button("保存") {
                             guard passcodeInput.count == 6, passcodeInput == passcodeConfirmInput else {
                                 passcodeTip = "两次输入不一致或非6位"
                                 return
                             }
                             do {
                                 try PasscodeManager.shared.setPasscode(passcodeInput)
                                 passcodeTip = "已设置密码"
                                 showingSetPasscode = false
                                 NotificationCenter.default.post(name: .passcodeDidChange, object: nil)
                             } catch {
                                 passcodeTip = "保存失败：\(error.localizedDescription)"
                             }
                         }
                         .disabled(passcodeInput.count != 6 || passcodeConfirmInput.count != 6)
                     }
                 }
+                .onAppear {
+                    // 打开设置密码页面时重置并自动聚焦第一个输入框
+                    passcodeInput = ""
+                    passcodeConfirmInput = ""
+                    passcodeTip = nil
+                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
+                        setPasscodeFieldFocused = true
+                    }
+                }
+                .onDisappear {
+                    passcodeInput = ""
+                    passcodeConfirmInput = ""
+                    passcodeTip = nil
+                    setPasscodeFieldFocused = false
+                    confirmPasscodeFieldFocused = false
+                }
             }
             .presentationDetents([.medium])
         }
     }
*** End Patch
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 2 files</summary>
      
Lint paths:

- `/Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift`
- `/Users/zgia/program/projects/zgia/book-reader/BookReader/BookReaderApp.swift`

Lint results


**No lint errors found**
</details>

---

- 已修复输入缓存：打开“设置密码”或“移除密码”弹窗时会清空输入与提示；关闭弹窗后也会清空，避免再打开时残留。
- 已实现自动聚焦与数字键盘：
  - 安全遮罩视图中的输入框在出现时自动聚焦并弹出数字键盘；解锁失败再次显示时也会清空并聚焦。
  - “设置密码”弹窗会自动聚焦第一个输入框；“移除密码”确认弹窗会自动聚焦密码输入框。
- 细节：在按钮点击进入弹窗前即重置相关输入状态；对焦使用 `@FocusState` 管理。

---

_**User (2025-09-17 03:12Z)**_

有个bug，每次进入@AppSettingsView.swift ，点击设置密码或者取消密码，弹出的sheet，会自动隐藏，再点击设置密码或者取消密码才不会隐藏

---

_**Assistant (gpt-5)**_



---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Fixing a bug with sheet behavior**

I need to address a bug in the AppSettingsView where tapping the set/remove passcode sheet hides immediately. It seems this could be due to conflicting sheet presentations, particularly if I’m using multiple .sheet modifiers. Although SwiftUI allows for multiple sheets, having them open simultaneously can create issues. I’m wondering if the onAppear triggers are resetting the state. My attempt to refactor to a single .sheet(item:) didn't apply properly because of mismatches in the current file, which still uses two separate sheets.
**Investigating sheet auto-hide issue**

I didn’t set showingSetPasscode in onAppear; instead, I focused on the passcodeInput string. The auto-hide issue might be due to using .sheet isPresented twice — it's possible that toggling one affects the other. There's also a .sheet for showingFormatHelp on the same view. This bug seems to happen only the first time, possibly linked to the focus modifier changing a state variable and dismissing the sheet. I’m considering a known issue in iOS 18/SwiftUI about presenting two sheets. Initially, I tried switching to a single .sheet(item:), which didn’t work — maybe I can revisit that approach.
**Updating state variables**

It seems I’ve been reflecting on earlier failed updates. In the current file, lines 18-23 define state variables, but they still use booleans. My goal is to add an enum called SecuritySheet and check if FocusState variables are present. Previously, we successfully introduced FocusState, but it looks like it's not included in the current version of AppSettingsView.swift. We had added FocusState in a past patch that succeeded, but it seems to have been lost as the user later modified the file. Right now, I only see passcode states.
**Implementing sheet consolidation**

It looks like the subsequent manual edits may have removed the FocusState variables, but it seems the bug with the sheet auto-hiding can be fixed by consolidating into a single .sheet(item:). Here’s my plan:

First, I’ll add an enum called SecuritySheet with cases for setPasscode and removePasscode. Then, I’ll introduce a private @State variable for securitySheet and remove the two existing .sheet(isPresented:) calls, replacing them with a consolidated .sheet(item: $securitySheet).

I’ll also extract the views into helper functions and reintroduce the FocusState variables for autofocusing. Lastly, I’ll ensure to reset inputs and update handles for the buttons.
**Refining sheet implementation**

I need to make sure we remove the previous two sheet presentations to avoid conflicts. Let's carefully implement this by referring to the existing code sections. I found the two .sheet blocks at around line 219 — one for showingRemovePasscodeConfirm and another for showingSetPasscode. I’ll replace these with a single .sheet(item:).

First, I’ll add FocusState variables and the securitySheet variable after the @State passcodeTip. Then, I’ll remove the showingSetPasscode and showingRemovePasscodeConfirm booleans currently occupying lines 18-19. This requires updating the file to match those lines exactly. Finally, I’ll revise button actions to set the securitySheet instead and add any necessary helper functions at the bottom.</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Reviewing file content**

I see that the additional data indicates a total of 496 lines, while our last read only had 423. This suggests the user has edited the file further. To ensure I have the correct content for patching, I’ll need to read the entire file again. It’s important to get this right so I can help effectively! Let's get started on that.</details></think>

---

我将先读取完整的 `AppSettingsView.swift` 以获取最新内容，然后合并为单一的基于枚举的 sheet 展示，避免首次点击自动隐藏的问题，并在其中保留自动聚焦与清空输入。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift

---

<think><details><summary>Thought Process</summary>**Fixing sheet bug**

I need to address a bug where, when entering the AppSettingsView, clicking the setting or removing the passcode sheet auto hides on the first try. I think this might be due to state toggling with multiple sheet modifiers, since SwiftUI allows only one .sheet per view at a time. The issue seems tied to how the securityView builder processes the form section, which may lead to dismissal if it re-evaluates. A typical fix would involve placing the sheet modifier on a stable ancestor.
**Refining sheet management**

Earlier, I mentioned unifying the sheet presentation using .sheet(item:) at the top level instead of attaching it to the Section. This could resolve the issue of ephemeral view identity that causes the first auto dismiss. My goal now is to replace the showingSetPasscode and showingRemovePasscodeConfirm booleans with a single enum, SecuritySheet. Then, I can implement the top-level .sheet(item:) in the NavigationStack to handle different sheets while adjusting button actions and preserving FocusState logic. Let's implement this edit!
**Implementing sheet updates**

I need to update my code to use .sheet(item: $securitySheet) and ensure it shows the right content. For the buttons in securityView, I should set securitySheet to either .removePasscode or .setPasscode instead of toggling the existing booleans. Next, I’ll remove the outdated .sheet blocks and introduce the helper views, setPasscodeSheetView and removePasscodeSheetView, along with the enum definition. I'll carefully maintain the indentation and style as I apply these changes in multiple segments. Let's get started with these modifications!
**Creating helper functions**

I need to replace the current setup with nothing for now and plan to add helper functions near the bottom of the file, just above appAppearanceView around line 372. I want to maintain a consistent code style by placing them under the main extension. It's essential to incorporate FocusState usage in the sheet view functions, as the FocusState variables are already part of the code and can be reused. I’ll craft this patch carefully in segments, ensuring no unnecessary imports are added. Let's get started on creating the patch!</details></think>

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: BookReader/Views/AppSettingsView.swift
@@
-    @State private var showingSetPasscode: Bool = false
-    @State private var showingRemovePasscodeConfirm: Bool = false
+    @State private var securitySheet: SecuritySheet?
@@
             .onAppear { refreshStatsAsync() }
             .sheet(isPresented: $showingFormatHelp) {
                 textBookFormatHelpView()
             }
+            .sheet(item: $securitySheet) { sheet in
+                if sheet == .setPasscode {
+                    setPasscodeSheetView()
+                } else {
+                    removePasscodeSheetView()
+                }
+            }
         }
     }
@@
-                    Button("移除密码", role: .destructive) {
+                    Button("移除密码", role: .destructive) {
                         passcodeInput = ""
                         passcodeTip = nil
-                        showingRemovePasscodeConfirm = true
+                        securitySheet = .removePasscode
                     }
                     .font(.footnote)
                 }
             } else {
                 HStack {
@@
-                    Button("设置密码") {
+                    Button("设置密码") {
                         passcodeInput = ""
                         passcodeConfirmInput = ""
                         passcodeTip = nil
-                        showingSetPasscode = true
+                        securitySheet = .setPasscode
                     }
                     .font(.footnote)
                 }
             }
         }
-        .sheet(isPresented: $showingRemovePasscodeConfirm) {
-            NavigationStack {
-                Form {
-                    Section(
-                        footer: Text(passcodeTip ?? "请输入当前6位密码以确认移除").font(
-                            .footnote
-                        ).foregroundColor(.secondary)
-                    ) {
-                        SecureField("当前密码", text: $passcodeInput)
-                            .keyboardType(.numberPad)
-                            .onChange(of: passcodeInput) { newValue, _ in
-                                passcodeInput = String(
-                                    newValue.filter { $0.isNumber }.prefix(6)
-                                )
-                            }
-                            .focused($removePasscodeFieldFocused)
-                    }
-                }
-                .navigationTitle("移除密码")
-                .toolbar {
-                    ToolbarItem(placement: .topBarLeading) {
-                        Button("取消") { showingRemovePasscodeConfirm = false }
-                    }
-                    ToolbarItem(placement: .topBarTrailing) {
-                        Button("移除", role: .destructive) {
-                            if PasscodeManager.shared.verifyPasscode(
-                                passcodeInput
-                            ) {
-                                do {
-                                    try PasscodeManager.shared.removePasscode()
-                                    passcodeTip = "已移除密码"
-                                    showingRemovePasscodeConfirm = false
-                                    NotificationCenter.default.post(
-                                        name: .passcodeDidChange,
-                                        object: nil
-                                    )
-                                } catch {
-                                    passcodeTip =
-                                        "移除失败：\(error.localizedDescription)"
-                                }
-                            } else {
-                                passcodeTip = "密码错误"
-                            }
-                        }
-                        .disabled(passcodeInput.count != 6)
-                    }
-                }
-                .onAppear {
-                    // 打开移除密码确认页面时重置并自动聚焦
-                    passcodeInput = ""
-                    passcodeTip = nil
-                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
-                        removePasscodeFieldFocused = true
-                    }
-                }
-                .onDisappear {
-                    passcodeInput = ""
-                    passcodeTip = nil
-                }
-            }
-            .presentationDetents([.medium])
-        }
-        .sheet(isPresented: $showingSetPasscode) {
-            NavigationStack {
-                Form {
-                    Section(
-                        footer: Text(passcodeTip ?? "密码需为6位数字").font(.footnote)
-                            .foregroundColor(.secondary)
-                    ) {
-                        SecureField("输入新密码", text: $passcodeInput)
-                            .keyboardType(.numberPad)
-                            .onChange(of: passcodeInput) { newValue, _ in
-                                passcodeInput = String(
-                                    newValue.filter { $0.isNumber }.prefix(6)
-                                )
-                            }
-                            .focused($setPasscodeFieldFocused)
-                        SecureField("再次输入", text: $passcodeConfirmInput)
-                            .keyboardType(.numberPad)
-                            .onChange(of: passcodeConfirmInput) { newValue, _ in
-                                passcodeConfirmInput = String(
-                                    newValue.filter { $0.isNumber }.prefix(6)
-                                )
-                            }
-                            .focused($confirmPasscodeFieldFocused)
-                    }
-                }
-                .navigationTitle("设置密码")
-                .toolbar {
-                    ToolbarItem(placement: .topBarLeading) {
-                        Button("取消") { showingSetPasscode = false }
-                    }
-                    ToolbarItem(placement: .topBarTrailing) {
-                        Button("保存") {
-                            guard passcodeInput.count == 6,
-                                passcodeInput == passcodeConfirmInput
-                            else {
-                                passcodeTip = "两次输入不一致或非6位"
-                                return
-                            }
-                            do {
-                                try PasscodeManager.shared.setPasscode(
-                                    passcodeInput
-                                )
-                                passcodeTip = "已设置密码"
-                                showingSetPasscode = false
-                                NotificationCenter.default.post(
-                                    name: .passcodeDidChange,
-                                    object: nil
-                                )
-                            } catch {
-                                passcodeTip =
-                                    "保存失败：\(error.localizedDescription)"
-                            }
-                        }
-                        .disabled(
-                            passcodeInput.count != 6
-                                || passcodeConfirmInput.count != 6
-                        )
-                    }
-                }
-                .onAppear {
-                    // 打开设置密码页面时重置并自动聚焦第一个输入框
-                    passcodeInput = ""
-                    passcodeConfirmInput = ""
-                    passcodeTip = nil
-                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
-                        setPasscodeFieldFocused = true
-                    }
-                }
-                .onDisappear {
-                    passcodeInput = ""
-                    passcodeConfirmInput = ""
-                    passcodeTip = nil
-                    setPasscodeFieldFocused = false
-                    confirmPasscodeFieldFocused = false
-                }
-            }
-            .presentationDetents([.medium])
-        }
+
     }
+
+    // MARK: - Sheets
+    private func setPasscodeSheetView() -> some View {
+        NavigationStack {
+            Form {
+                Section(footer: Text(passcodeTip ?? "密码需为6位数字").font(.footnote).foregroundColor(.secondary)) {
+                    SecureField("输入新密码", text: $passcodeInput)
+                        .keyboardType(.numberPad)
+                        .onChange(of: passcodeInput) { newValue, _ in
+                            passcodeInput = String(newValue.filter { $0.isNumber }.prefix(6))
+                        }
+                        .focused($setPasscodeFieldFocused)
+                    SecureField("再次输入", text: $passcodeConfirmInput)
+                        .keyboardType(.numberPad)
+                        .onChange(of: passcodeConfirmInput) { newValue, _ in
+                            passcodeConfirmInput = String(newValue.filter { $0.isNumber }.prefix(6))
+                        }
+                        .focused($confirmPasscodeFieldFocused)
+                }
+            }
+            .navigationTitle("设置密码")
+            .toolbar {
+                ToolbarItem(placement: .topBarLeading) {
+                    Button("取消") { securitySheet = nil }
+                }
+                ToolbarItem(placement: .topBarTrailing) {
+                    Button("保存") {
+                        guard passcodeInput.count == 6, passcodeInput == passcodeConfirmInput else {
+                            passcodeTip = "两次输入不一致或非6位"
+                            return
+                        }
+                        do {
+                            try PasscodeManager.shared.setPasscode(passcodeInput)
+                            passcodeTip = "已设置密码"
+                            securitySheet = nil
+                            NotificationCenter.default.post(name: .passcodeDidChange, object: nil)
+                        } catch {
+                            passcodeTip = "保存失败：\(error.localizedDescription)"
+                        }
+                    }
+                    .disabled(passcodeInput.count != 6 || passcodeConfirmInput.count != 6)
+                }
+            }
+            .onAppear {
+                passcodeInput = ""
+                passcodeConfirmInput = ""
+                passcodeTip = nil
+                DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
+                    setPasscodeFieldFocused = true
+                }
+            }
+            .onDisappear {
+                passcodeInput = ""
+                passcodeConfirmInput = ""
+                passcodeTip = nil
+                setPasscodeFieldFocused = false
+                confirmPasscodeFieldFocused = false
+            }
+        }
+        .presentationDetents([.medium])
+    }
+
+    private func removePasscodeSheetView() -> some View {
+        NavigationStack {
+            Form {
+                Section(footer: Text(passcodeTip ?? "请输入当前6位密码以确认移除").font(.footnote).foregroundColor(.secondary)) {
+                    SecureField("当前密码", text: $passcodeInput)
+                        .keyboardType(.numberPad)
+                        .onChange(of: passcodeInput) { newValue, _ in
+                            passcodeInput = String(newValue.filter { $0.isNumber }.prefix(6))
+                        }
+                        .focused($removePasscodeFieldFocused)
+                }
+            }
+            .navigationTitle("移除密码")
+            .toolbar {
+                ToolbarItem(placement: .topBarLeading) {
+                    Button("取消") { securitySheet = nil }
+                }
+                ToolbarItem(placement: .topBarTrailing) {
+                    Button("移除", role: .destructive) {
+                        if PasscodeManager.shared.verifyPasscode(passcodeInput) {
+                            do {
+                                try PasscodeManager.shared.removePasscode()
+                                passcodeTip = "已移除密码"
+                                securitySheet = nil
+                                NotificationCenter.default.post(name: .passcodeDidChange, object: nil)
+                            } catch {
+                                passcodeTip = "移除失败：\(error.localizedDescription)"
+                            }
+                        } else {
+                            passcodeTip = "密码错误"
+                        }
+                    }
+                    .disabled(passcodeInput.count != 6)
+                }
+            }
+            .onAppear {
+                passcodeInput = ""
+                passcodeTip = nil
+                DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
+                    removePasscodeFieldFocused = true
+                }
+            }
+            .onDisappear {
+                passcodeInput = ""
+                passcodeTip = nil
+                removePasscodeFieldFocused = false
+            }
+        }
+        .presentationDetents([.medium])
+    }
+
+    private enum SecuritySheet: Identifiable, Equatable {
+        case setPasscode
+        case removePasscode
+        var id: String { self == .setPasscode ? "set" : "remove" }
+    }
*** End Patch
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 1 file</summary>
      
Lint paths:

- `/Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift`

Lint results


**No lint errors found**
</details>

---

- 我已修复首次点击弹出的 sheet 自动消失的问题：将两个布尔弹窗改为单一基于枚举的 `.sheet(item:)`，避免状态竞争导致的立即dismiss。
- 同时保留了自动聚焦与清空逻辑，进入“设置密码/移除密码”都会重置输入并在出现后聚焦相应输入框。
- 入口按钮在设置前已清空输入和提示，确保不会带入旧值。

请在设置页再次尝试“设置密码”和“移除密码”，首次点击应不会再自动隐藏。

---

_**User (2025-09-17 03:12Z)**_

@AppSettingsView.swift 现在不会自动隐藏了，但是输入密码时，输入的内容会快速闪动，无法继续输入

可以将sheet改成，弹出一个Dialog，有2个输入框，会不会好处理些？

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Diagnosing AppSettingsView issues**

I need to address a bug in AppSettingsView where the SecureField input flickers, making it impossible to continue typing. This might be due to state updates triggering re-renders of the sheet. I wonder if the FocusState is causing this jump and if the input field resets with onAppear. There's also the issue with the computed SecuritySheet enum. The flicker likely results from the sheet's evaluation and state changes. I'll delve deeper into these possible causes.
**Investigating SecureField flicker**

In SwiftUI, I’m noticing that the SecureField with keyboardType set to .numberPad doesn’t accept repeated updates when the text is mutated in onChange. This might be causing continuous updates, which seems normal enough. However, flicker issues could stem from the sheet's focus inference causing repeated onAppear triggers. In AppSettingsView, calling .sheet(item:) may be resetting passcodeInput every time the view identity changes, leading to inadvertent clearing while typing. I need to explore these potential causes further.
**Analyzing flicker causes**

The flickering issue in the SecureField might come from the "Form" inside the sheet combined with FocusState toggling. The password masking with bullets could be causing this reset due to .onChange, which filters the input. Each character typed triggers a filtered version, but if it's valid, it still assigns the same string, so the cursor resets, although flickering shouldn't occur. The user's suggestion is to switch to a dialog with two input fields, but I might need to build that custom overlay since the existing TextFieldDialog only supports one field.
**Creating a custom modal overlay**

It seems like the current approach might not be stable, so I’m considering creating a custom modal overlay in AppSettingsView. By using fullScreenCover or conditionally displaying a VStack with content when `showDialog` is true, I could avoid issues with the sheet. I plan to implement two components, `PasscodeSetDialog` and `PasscodeRemoveDialog`, in Components.swift or directly in AppSettingsView. I think extending Components.swift with a general `TwoSecureFieldsDialog` could be beneficial, but I also need to decide about using overlay state for displaying the dialog.</details></think>

---

我将把设置/移除密码的弹窗从 sheet 改为自定义对话框（Dialog）覆盖层，避免输入时闪动；同时保留自动聚焦与输入清空。在更新前后都会确保输入状态稳定。现在开始修改 `AppSettingsView.swift`。

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Planning file modifications**

I think we need to re-open the file to apply targeted edits instead of missing important contexts. We’ve already read through the file, so let's plan the changes:  

At the top, I want to replace the two variables `showingSetPasscode` and `showingRemovePasscodeConfirm` with one `securityDialog`. However, I still want to keep the `FocusStates`. The current version has those two booleans, and we will remove them, adding the new variable instead. I need to ensure the overlays are set up correctly in the UI.
**Updating security dialog functionality**

I need to see how to enhance the security dialog functionality. First, I'll add `.overlay(securityDialogOverlay())` right after the sheet for format help, specifically in the area around lines 46-47. 

In the `securityView()` function, I'll change the button actions in the HStack to set the `securityDialog` to `.removePasscode` or `.setPasscode` as needed. This means removing the existing `.sheet` modifiers in lines 231-370 entirely. Finally, I’ll introduce new functions for `securityDialogOverlay()`, `handleSecurityDialogPrimaryAction()`, and an enum for `SecurityDialog`, while also managing input focus and clearing before presenting.
**Modifying securityView function**

In the `securityView` function, I need to update the button actions to set `securityDialog` to either `.removePasscode` or `.setPasscode`. 

Next, I'll remove the two `.sheet` modifiers that appear after the Section, specifically in lines 231-370, and completely delete those blocks. After that, I'll append new functions at the end of the struct before `appAppearanceView`: these will include `securityDialogOverlay()`, `handleSecurityDialogPrimaryAction()`, and the `SecurityDialog` enum. Finally, I plan to implement the patch using `apply_patch` with the correct context.</details></think>

---

我将把设置/移除密码的 sheet 改为自定义对话框覆盖层，修复输入时闪动的问题：新增 `securityDialog` 状态与 overlay 视图，替换两个 `.sheet`，在按钮点击和对话框出现时清空并自动聚焦输入框。现在进行精确编辑。

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Troubleshooting user bug**

I need to address the user's bug where, when typing in sheet input fields, the content flashes and they can't continue. One solution might be to switch to a Dialog overlay. I tried to edit the file to facilitate this change, but the patch failed. It seems the file still has the necessary variables like showingSetPasscode and showingRemovePasscodeConfirm, which makes me question why the update didn't work. It's possible I need to revisit how we implemented the changes in the file.
**Investigating patch failure**

The failure message indicates it couldn't find the context for showingSetPasscode, even though those lines are present in the file. This might be due to whitespace or differences in comments. I checked again, and the lines exist at L18-L19: they should match. It seems that apply_patch can fail if earlier changes aren't identical. I could try using smaller, more precise patches, or show substrings around those lines to confirm their text. I plan to create a patch by replacing those lines with a securityDialog variable and keeping FocusStates intact.
**Making updates for the patch**

I’m going to add a hunk by updating button actions to set the securityDialog instead of toggling booleans. I’ll also remove the two .sheet blocks for showingRemovePasscodeConfirm and showingSetPasscode. This might be a bit tricky because I need to delete everything from ".sheet(isPresented: $showingRemovePasscodeConfirm) {" to its closing "}". 

Instead of making large changes that may lead to errors, I should address the flickering issue by avoiding state changes inside onChange loops, which can cause those flashing issues. It seems to happen when resetting passcodeInput while focusing.
**Addressing the flicker issue**

I think the flickering might be happening because of two sheets being used simultaneously, even though there was an earlier change to item-based sheets. It looks like the current file still has those .sheet booleans, so maybe some earlier changes were lost. The flicker could be resulting from .sheet having focus states that reset the view when the text changes. 

However, since the user explicitly requested changing to a Dialog overlay, I'll follow that direction and implement the overlay step by step to ensure everything transitions smoothly. I plan to first replace the boolean variables and then gradually move on to the overlay implementation, replacing button actions and finally removing the .sheet blocks.
**Implementing changes for the overlay**

I’m realizing that removing large code blocks can be error-prone. Instead of deleting the old .sheet blocks, I could keep them but guard them with a false condition. However, showingRemovePasscodeConfirm and showingSetPasscode should default to false and won’t be actively set anywhere. Although we prefer to remove them for clarity, they could still compile. 

To avoid compilation errors, I’ll keep the existing booleans while adding the securityDialog variable. I plan to change button actions to use this new variable instead. 

My patch plan involves several steps: I’ll add the new state variable, define the overlay function, and handle actions accordingly without deleting existing code blocks. I’ll implement this in multiple hunks. First, I’ll insert the securityDialog variable at the appropriate place, add the overlay call, and update the button actions. Then I’ll finish by defining the necessary functions before closing the struct.</details></think>

---

我将更新设置页为使用自定义覆盖式对话框，避免 sheet 输入闪动问题：添加新的对话框状态，注入 overlay，修改按钮行为，并实现对话框内容与提交逻辑。

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>**Editing code for sheet modifiers**

I'm figuring out how to edit the .sheet modifiers for showingRemovePasscodeConfirm and showingSetPasscode. I can delete the large blocks of code between these modifiers, but since the edit_file tool can only handle single occurrences, I need to replace them with nothing. It seems tricky because I can’t straightforwardly delete a large block. I might need to use placeholders or leave them as they are, considering our plans to stop toggling those sheets.
**Updating sheet blocks in the code**

I see that it's okay to leave the .sheet blocks since they rely on booleans, but removing those booleans caused compile errors. I must either remove or update them. One option is to replace the first ".sheet(isPresented: $showingRemovePasscodeConfirm) { ... }" with an empty ".onChange(of: securityDialog) { _, _ in }". However, if I go that route, I risk creating unmatched braces, which isn't ideal. Maybe I should just keep the booleans to avoid those complications.
**Adjusting boolean handling for dialog overlay**

The user requested a dialog overlay, which means I need to consider how to handle the booleans. It’s not ideal to keep them if they are unused, but at least it compiles. The plan was to remove them, but since deletion can be tricky, maybe I should just keep them set to false. This way, their sheets exist but aren’t activated, minimizing risks. Instead, I’ll modify the earlier edit by adding the `securityDialog` property while retaining the existing booleans, which seems like the simplest solution!
**Modifying button actions for security dialog**

I need to change the button actions so that instead of toggling the sheets, they set the `securityDialog`. If I don’t make this change, both the overlay and the sheet could appear when the user toggles the booleans. I’ll keep the booleans unchanged at false and leave the existing sheets, which won't interfere since they won’t display. 

For the fifth edit, I'll add the overlay function along with a helper and enum before the struct ends. So, first, I’ll insert the `securityDialog` state line, replacing the relevant segment appropriately. Let's go ahead and do that!
**Making updates to the overlay and buttons**

First, I need to add the overlay for the `securityDialog`. After the line for showing the format help, I’ll insert ".overlay(securityDialogOverlay())". Next, I'll update the "移除密码" button, changing "showingRemovePasscodeConfirm = true" to "securityDialog = .removePasscode". For the "设置密码" button, I’ll set it to "securityDialog = .setPasscode" instead of toggling the previous state.

Additionally, I’ll need to append the overlay functions and enum right before the closing brace of the struct. I’ll replace the last few lines with the appropriate code for the overlay functions. Let's go ahead and do that!</details></think>

---

Tool use: **edit_file**


<details><summary>Edit file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift</summary>

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -16,4 +16,5 @@
      @State private var statsText: String = ""
      @State private var showingFormatHelp: Bool = false
+     @State private var securityDialog: SecurityDialog?
      @State private var securitySheet: SecuritySheet?
      @State private var passcodeInput: String = ""
```

</details>

---

Tool use: **edit_file**


<details><summary>Edit file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift</summary>

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -45,4 +45,5 @@
                  textBookFormatHelpView()
              }
+             .overlay(securityDialogOverlay())
              .sheet(item: $securitySheet) { sheet in
                  if sheet == .setPasscode {
```

</details>

---

Tool use: **edit_file**


<details><summary>Edit file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -216,5 +216,5 @@
                          passcodeInput = ""
                          passcodeTip = nil
-                         securitySheet = .removePasscode
+                         securityDialog = .removePasscode
                      }
                      .font(.footnote)
```

**Chunk 2**
Lines added: 1, lines removed: 1

```diff
@@ -231,5 +231,5 @@
                          passcodeConfirmInput = ""
                          passcodeTip = nil
-                         securitySheet = .setPasscode
+                         securityDialog = .setPasscode
                      }
                      .font(.footnote)
```

**Chunk 3**
Lines added: 121, lines removed: undefined

```diff
@@ -502,4 +502,125 @@
          }
      }
+ 
+     // MARK: - Dialog Overlay
+     @ViewBuilder
+     private func securityDialogOverlay() -> some View {
+         if let dialog = securityDialog {
+             ZStack {
+                 Color.black.opacity(0.35).ignoresSafeArea()
+                 VStack(spacing: 16) {
+                     Text(dialog.title)
+                         .font(.headline)
+                     if dialog == .setPasscode {
+                         VStack(spacing: 10) {
+                             SecureField("输入新密码", text: $passcodeInput)
+                                 .keyboardType(.numberPad)
+                                 .focused($setPasscodeFieldFocused)
+                                 .onChange(of: passcodeInput) { newValue, _ in
+                                     let filtered = String(newValue.filter { $0.isNumber }.prefix(6))
+                                     if filtered != newValue { passcodeInput = filtered }
+                                 }
+                                 .textContentType(.oneTimeCode)
+                                 .padding(10)
+                                 .background(Color(.secondarySystemBackground))
+                                 .clipShape(RoundedRectangle(cornerRadius: 8))
+                             SecureField("再次输入", text: $passcodeConfirmInput)
+                                 .keyboardType(.numberPad)
+                                 .focused($confirmPasscodeFieldFocused)
+                                 .onChange(of: passcodeConfirmInput) { newValue, _ in
+                                     let filtered = String(newValue.filter { $0.isNumber }.prefix(6))
+                                     if filtered != newValue { passcodeConfirmInput = filtered }
+                                 }
+                                 .textContentType(.oneTimeCode)
+                                 .padding(10)
+                                 .background(Color(.secondarySystemBackground))
+                                 .clipShape(RoundedRectangle(cornerRadius: 8))
+                         }
+                     } else {
+                         SecureField("当前密码", text: $passcodeInput)
+                             .keyboardType(.numberPad)
+                             .focused($removePasscodeFieldFocused)
+                             .onChange(of: passcodeInput) { newValue, _ in
+                                 let filtered = String(newValue.filter { $0.isNumber }.prefix(6))
+                                 if filtered != newValue { passcodeInput = filtered }
+                             }
+                             .textContentType(.oneTimeCode)
+                             .padding(10)
+                             .background(Color(.secondarySystemBackground))
+                             .clipShape(RoundedRectangle(cornerRadius: 8))
+                     }
+                     if let tip = passcodeTip, !tip.isEmpty {
+                         Text(tip)
+                             .font(.footnote)
+                             .foregroundColor(.secondary)
+                             .multilineTextAlignment(.center)
+                     }
+                     HStack {
+                         Button("取消") { securityDialog = nil }
+                             .frame(maxWidth: .infinity)
+                         Button(dialog.primaryActionTitle) {
+                             handleSecurityDialogPrimaryAction(dialog)
+                         }
+                         .disabled(dialog == .setPasscode ? !(passcodeInput.count == 6 && passcodeConfirmInput.count == 6) : passcodeInput.count != 6)
+                         .frame(maxWidth: .infinity)
+                     }
+                 }
+                 .padding(20)
+                 .background(.regularMaterial)
+                 .clipShape(RoundedRectangle(cornerRadius: 14))
+                 .padding(.horizontal, 40)
+                 .onAppear {
+                     DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
+                         switch dialog {
+                         case .setPasscode: setPasscodeFieldFocused = true
+                         case .removePasscode: removePasscodeFieldFocused = true
+                         }
+                     }
+                 }
+             }
+         } else {
+             EmptyView()
+         }
+     }
+ 
+     private func handleSecurityDialogPrimaryAction(_ dialog: SecurityDialog) {
+         switch dialog {
+         case .setPasscode:
+             guard passcodeInput.count == 6, passcodeInput == passcodeConfirmInput else {
+                 passcodeTip = "两次输入不一致或非6位"
+                 return
+             }
+             do {
+                 try PasscodeManager.shared.setPasscode(passcodeInput)
+                 passcodeTip = "已设置密码"
+                 securityDialog = nil
+                 NotificationCenter.default.post(name: .passcodeDidChange, object: nil)
+             } catch {
+                 passcodeTip = "保存失败：\(error.localizedDescription)"
+             }
+         case .removePasscode:
+             if PasscodeManager.shared.verifyPasscode(passcodeInput) {
+                 do {
+                     try PasscodeManager.shared.removePasscode()
+                     passcodeTip = "已移除密码"
+                     securityDialog = nil
+                     NotificationCenter.default.post(name: .passcodeDidChange, object: nil)
+                 } catch {
+                     passcodeTip = "移除失败：\(error.localizedDescription)"
+                 }
+             } else {
+                 passcodeTip = "密码错误"
+             }
+         }
+         passcodeInput = ""
+         passcodeConfirmInput = ""
+     }
+ 
+     private enum SecurityDialog: Equatable {
+         case setPasscode
+         case removePasscode
+         var title: String { self == .setPasscode ? "设置密码" : "移除密码" }
+         var primaryActionTitle: String { self == .setPasscode ? "保存" : "移除" }
+     }
  }
  
```

</details>

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 1 file</summary>
      
Lint paths:

- `/Users/zgia/program/projects/zgia/book-reader/BookReader/Views/AppSettingsView.swift`

Lint results


**No lint errors found**
</details>

---

- 我已将设置/移除密码从 sheet 改为自定义覆盖式对话框（Dialog overlay），避免输入框闪动和自动隐藏问题。
- 对话框在打开时自动聚焦对应输入框，并且按钮点击前已清空输入；提交逻辑与校验保持一致，完成后发送 `passcodeDidChange`。
- 原先的两个 sheet 仍然保留但入口按钮改用对话框，不会再触发它们；后续若需要可移除旧 sheet 代码。

---

