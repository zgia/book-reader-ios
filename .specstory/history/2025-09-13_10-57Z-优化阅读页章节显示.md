<!-- Generated by SpecStory -->

<!-- cursor Session 2b2d2f41-a261-4c52-8459-aecf7c51ccbb (2025-09-13 10:57Z) -->

# 优化阅读页章节显示 (2025-09-13 10:57Z)

_**User (2025-09-13 10:31Z)**_

发现一个小bug，阅读页，比如当前是第70章，查看目录列表时，顶部显示的是第71章，而第70章却被隐藏了。建议这么处理：

顶部显示当前章的前5章，比如第65章。如果当前章是，第1章，则顶部显示第1章；当前章是第2章，则顶部显示第1章；以此类推。如果是最后一章，则显示在底部。

即给当前章一个合适的位置

---

_**Assistant (gpt-5)**_

<think><details><summary>Thought Process</summary>**Fixing a Swift UI Bug**

I need to address a bug in a Swift/SwiftUI app related to the reading page. The chapter list currently hides the current chapter and displays the next one instead. The desired behavior should show the previous up to five chapters before the current one at the top, addressing edge cases like being at the beginning or end of the list. I should look into files like `ChapterListView.swift` or `ReaderView.swift`, particularly where the `ScrollViewReader` is used to adjust scrolling behavior. I'll start with a status update and then search through the code.
**Searching for Chapter List Logic**

I need to conduct a broad search through the codebase to find the chapter list code and the scroll position logic. I’m thinking about running parallel searches: one semantic search for where the chapter list is rendered or scrolled, and another using grep to search for terms like `ChapterListView`, `scrollTo`, and `ScrollViewReader`. Since this might involve editing just one file, I want to create a small to-do list with 2-3 items to outline steps like locating behavior and implementing proper scroll positioning. I'll use `todo_write` to manage these tasks. Let's get started!</details></think>

---

我先快速定位目录列表和滚动定位的实现位置，然后查找是否有 `ScrollViewReader`/`scrollTo` 或章节索引计算的逻辑，便于修复“当前章被隐藏并显示下一章在顶部”的问题。接下来我会并行搜索相关代码位置。

---

Tool use: **codebase_search**

---

Tool use: **grep**

<details>
<summary>Grep for "ScrollViewReader|scrollTo\(|scrollPosition|proxy\.scrollTo" in "/Users/zgia/program/projects/zgia/book-reader/" • 9 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./BookReader/Views/ReaderView.swift` | `ScrollViewReader \{ proxy in` | L258 |
| `./BookReader/Views/ReaderView.swift` | `"📖 ScrollViewReader.onAppear pages=\(pages.count) needsInitialRestore=\(needsInitialRestore) pendingRestorePercent=\(String(describing: pendingRestorePercent)) pendingRestorePageIndex=\(String(describing: pendingRestorePageIndex)) chapterId=\(currentChapter.id)"` | L427 |
| `./BookReader/Views/ReaderView.swift` | `"📖 ScrollViewReader.onAppear: no pending restore, skip"` | L469 |
| `./BookReader/Views/ReaderView.swift` | `"📖 ScrollViewReader.onAppear: pages empty, skip"` | L474 |
| `./BookReader/Views/ReaderView.swift` | `withAnimation \{ proxy.scrollTo(anchorId, anchor: .top) \}` | L1001 |
| `./BookReader/Views/ReaderView.swift` | `proxy.scrollTo(anchorId, anchor: .top)` | L1003 |
| `./BookReader/Views/ReaderView.swift` | `// 使用 ScrollViewReader 的 anchor id 恢复` | L1174 |
| `./BookReader/Views/ChapterListView.swift` | `ScrollViewReader \{ proxy in` | L15 |
| `./BookReader/Views/ChapterListView.swift` | `proxy.scrollTo(targetId, anchor: .top)` | L172 |


</details>

---

Tool use: **grep**

<details>
<summary>Grep for "ChapterListView" in "/Users/zgia/program/projects/zgia/book-reader/" • 2 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./BookReader/Views/ReaderView.swift` | `ChapterListView(` | L122 |
| `./BookReader/Views/ChapterListView.swift` | `struct ChapterListView: View \{` | L4 |


</details>

---



---

我找到了目录列表 `ChapterListView` 中使用 `ScrollViewReader` 和 `scrollTo` 的位置。现在我会打开该文件查看当前滚动定位逻辑，并检查如何计算目标 anchor id，以便实现“当前章前5章置顶，边界情况处理”的需求。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/ChapterListView.swift

---

<think><details><summary>Thought Process</summary>**Fixing chapter list bug**

I need to implement a bug fix related to the chapter list in the reader. If the current chapter is 70, it shows chapter 71 at the top while hiding 70. I see that the code in ChapterListView uses `attemptAutoScroll` to scroll to the target chapter. It seems that the pinned section header is causing 70 to be hidden under it, which aligns with the behavior where 71 shows but not 70. I’ll need to address the pinned header issue!
**Addressing chapter scrolling issue**

I’ve realized that the pinned headers are causing the issue. When I scroll to align the target cell at the top, the pinned header makes the current chapter hidden behind it. That's why we see chapter 71 visible below the header, while chapter 70 is hidden. To fix this, I’ll offset the scroll anchor to show five items above the current chapter. I’ll compute the index of the current chapter and adjust the scrolling target accordingly. If it's near the end, chapter visibility may need adjustments too!
**Implementing chapter positioning**

I need to ensure that if the current chapter is the last one, it displays at the bottom of the viewport. I’ll compute the `startIndex` as `max(currentIndex - 5, 0)` and scroll to that with an anchor at the top. This allows for up to five chapters to be visible above the current chapter. For the last chapter, I think using an anchor at the bottom to avoid it being cut off by the pinned header makes sense. I’ll need to adjust for visibility accordingly!
**Navigating viewport and anchors**

I realize we don't know the viewport height, but using a bottom anchor on the last chapter ensures it’s positioned at the bottom of the visible area. However, pinned headers may still interfere by overlaying the top. If the last item is within a section, the bottom anchor should work fine. I also need to consider the differences in handling the search mode list versus a scroll view. In search mode, they use a List but without a ScrollViewReader wrapper, although it seems SwiftUI's List can work with it. I have some complexities to handle!
**Checking initialChapterId**

I’m looking at how ReaderView initializes ChapterListView with `book: book` and a selection handler, but it seems the `initialChapterId` isn’t being passed. I need to confirm this by examining the relevant section of ReaderView.swift, particularly around line 120. I may need to open that file to verify how it’s set up and ensure everything is functioning as intended regarding the chapter selection process. It's essential to clarify this!</details></think>

---

我将先查看 `ReaderView` 中如何创建 `ChapterListView`，确认 `initialChapterId` 的传递逻辑，以确保修复滚动定位时能够获取当前章节索引。随后我会在 `ChapterListView.attemptAutoScroll` 中实现“前5章置顶/最后一章底部”的滚动定位逻辑。

---

Tool use: **read_file**

Read file: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/ReaderView.swift

---

<think><details><summary>Thought Process</summary>**Implementing autoscroll changes**

I need to set `didAutoScroll` to true right after the scroll is executed. Also, I should ensure a boundary for the last chapter along with the anchor at the bottom. It’s important to keep the update animated with a small duration. I need to consider edge cases where `searchText` isn't empty — if it’s filtered, the chapter might not show. I'll also implement changes to ensure maintained indentation and use `apply_patch` for modifying the file.
**Modifying autoscroll behavior**

I need to make sure that `attemptAutoScroll` is called after volumes or chapters are loaded. Right now, it flows from `loadData()` to `attemptAutoScroll(proxy)` in `onAppear`. But since `loadData` reads from GRDB synchronously on the same thread, it updates chapters right away, while `attemptAutoScroll` uses `DispatchQueue.main.async` for animation. Thankfully, the synchronous update works fine. I’ll implement changes to `attemptAutoScroll`, including guard statements, calculating the index, and managing the scroll target for the last chapter specifically.
**Reviewing chapter scrolling behavior**

The spec suggests that if it's the last chapter, it should display at the bottom. For chapters near the end, we’d show 5 above the top, which seems reasonable. I also need to consider if a pinned section header might hide rows when the `adjustedIndex` is 0. The height of the pinned header is around 44, plus potentially 2 lines for the summary. Additionally, while dealing with `filteredChapters`, if `searchText` isn't empty, the `scrollTargetId` might not correspond to the current chapters. I should check if `searchText` is empty and adjust scrolling accordingly.
**Adjusting auto-scrolling logic**

The requirement is mainly for the directory list by default, so I’ll keep it generic and safe. For non-empty searches, I’ll maintain the anchor at `.top` for `targetId`, but `attemptAutoScroll` needs to be aware of `searchText`. Since `searchText` is accessible within the struct, I can structure it like this: if `searchText.isEmpty`, then compute the adjusted index; otherwise, consider anchoring to `.center` for `targetId`. 

To prevent issues, I’ll only attempt auto-scroll when `searchText` is empty and ensure a guard clause is added to handle that condition.
**Implementing anchor adjustments**

I need to ensure that the changes won’t interfere with search functionality. I’ll set the anchor to `.bottom` for the last chapter, which makes sure it appears at the bottom of the viewport. Next, I’m considering if I should adjust for the last few chapters—just for the last chapter, it makes sense to use `.bottom`, while for the second-to-last, I could keep the earlier 5 chapters visible.

I’ll keep code indentation consistent with 4 spaces. Lastly, I'll note that while it’s a small change, I won’t be updating the TODO list since this is a simple task. I'll also run a linter check on the file after implementing these edits.</details></think>

---

我将更新 `ChapterListView.attemptAutoScroll` 的滚动逻辑：为当前章节计算“前5章”的锚点，并对首章与末章做边界处理（首章从顶部显示，末章从底部显示）；另外避免在搜索模式下干扰滚动。接下来我会直接进行代码编辑并随后检查是否有新的 lint 报错。

---

Tool use: **apply_patch**

<details>
        <summary>Apply patch for /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/ChapterListView.swift</summary>
      

```diff
*** Begin Patch
*** Update File: /Users/zgia/program/projects/zgia/book-reader/BookReader/Views/ChapterListView.swift
@@
     private func attemptAutoScroll(_ proxy: ScrollViewProxy) {
-        guard !didAutoScroll, let targetId = initialChapterId else { return }
-        let exists = chapters.contains(where: { $0.id == targetId })
-        guard exists else { return }
-        DispatchQueue.main.async {
-            withAnimation(.easeInOut(duration: 0.2)) {
-                proxy.scrollTo(targetId, anchor: .top)
-            }
-            didAutoScroll = true
-        }
+        // 仅在非搜索模式下自动滚动，避免影响搜索结果列表
+        guard searchText.isEmpty else { return }
+        guard !didAutoScroll, let targetId = initialChapterId else { return }
+        guard let idx = chapters.firstIndex(where: { $0.id == targetId }) else { return }
+
+        // 计算合适的定位：当前章的前 5 章置顶；如果不足 5 章，则置顶第 1 章
+        // 如果是最后一章，则将其显示在底部
+        let isLastChapter = (idx == chapters.count - 1)
+        let scrollTargetId: Int
+        let anchor: UnitPoint
+        if isLastChapter {
+            scrollTargetId = targetId
+            anchor = .bottom
+        } else {
+            let adjustedIndex = max(idx - 5, 0)
+            scrollTargetId = chapters[adjustedIndex].id
+            anchor = .top
+        }
+
+        DispatchQueue.main.async {
+            withAnimation(.easeInOut(duration: 0.2)) {
+                proxy.scrollTo(scrollTargetId, anchor: anchor)
+            }
+            didAutoScroll = true
+        }
     }
*** End Patch
```

---

Tool use: **read_lints**

<details>
          <summary>Read lints for 1 file</summary>
      
Lint paths:

- `/Users/zgia/program/projects/zgia/book-reader/BookReader/Views/ChapterListView.swift`

Lint results


**No lint errors found**
</details>

---

我已定位并修复目录页的自动滚动定位逻辑，确保“当前章获得合适位置”。

- 我在 `ChapterListView.attemptAutoScroll` 中改为：
  - 非搜索模式才自动滚动；
  - 计算当前章索引，若为最后一章，则滚动并使用 `.bottom` 锚点；否则将“当前章的前5章”置顶（不足5章时置顶第1章），用 `.top` 锚点。
- 这能避免你提到的“顶部显示第71章、而第70章被隐藏”的情况，并满足前5章的可见性要求。

你可以在阅读页打开目录验证：
- 当前在第70章，目录应将第65章置顶；
- 在第1或第2章，目录顶部仍是第1章；
- 在最后一章，当前章会靠底部显示。

---

